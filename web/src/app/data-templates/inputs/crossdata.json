  {
    "name": "Crossdata",
    "icon": "",
    "modelType": "Crossdata",
    "description": {
      "short": "Allows you to load data from external Datasources using Crossdata and monitoring tables migrating data in streaming processes with finite or infinite duration",
      "long": "Input used for reading data from tables using Crossdata and Spark. It is possible to migrate data in streaming processes with finite or infinite duration",
      "learnMore": ""
    },
    "properties": [
      {
        "propertyId": "query",
        "propertyName": "_QUERY_",
        "propertyType": "text",
        "with": 12,
        "required": true,
        "tooltip": "Query to read data from. Example: select * from tableName",
        "qa": "fragment-details-crossdata-query"
      },
      {
        "propertyId": "storageLevel",
        "propertyName": "_STORAGELEVEL_",
        "propertyType": "select",
        "required": true,
        "default": "MEMORY_ONLY_SER",
        "tooltip": "Default Storage Level assigned to Spark Streaming batches",
        "qa": "policy-storage-level",
        "values": [
          {
            "label": "DISK_ONLY",
            "value": "DISK_ONLY"
          },
          {
            "label": "DISK_ONLY_2",
            "value": "DISK_ONLY_2"
          },
          {
            "label": "MEMORY_ONLY",
            "value": "MEMORY_ONLY"
          },
          {
            "label": "MEMORY_ONLY_2",
            "value": "MEMORY_ONLY_2"
          },
          {
            "label": "MEMORY_ONLY_SER",
            "value": "MEMORY_ONLY_SER"
          },
          {
            "label": "MEMORY_ONLY_SER_2",
            "value": "MEMORY_ONLY_SER_2"
          },
          {
            "label": "MEMORY_AND_DISK",
            "value": "MEMORY_AND_DISK"
          },
          {
            "label": "MEMORY_AND_DISK_2",
            "value": "MEMORY_AND_DISK_2"
          },
          {
            "label": "MEMORY_AND_DISK_SER",
            "value": "MEMORY_AND_DISK_SER"
          },
          {
            "label": "MEMORY_AND_DISK_SER_2",
            "value": "MEMORY_AND_DISK_SER_2"
          }
        ]
      },
      {
        "propertyId": "outputFormat",
        "propertyName": "_OUTPUT_FORMAT_",
        "propertyType": "select",
        "values": [
          {
            "label": "Json",
            "value": "JSON"
          },
          {
            "label": "Row",
            "value": "ROW"
          }
        ],
        "default": "JSON",
        "required": true,
        "tooltip": "Sets whether the output values should be written as Json or Row with one separator character.",
        "qa": "fragment-details-crossdata-outputformat"
      },
      {
        "propertyId": "rowSeparator",
        "propertyName": "_KAFKA_ROW_SEPARATOR_",
        "propertyType": "text",
        "default": ",",
        "visible": [
          [
            {
              "propertyId": "outputFormat",
              "value": "ROW"
            }
          ]
        ],
        "required": false,
        "qa": "fragment-details-crossdata-row-separator"
      },
      {
        "propertyId": "limitRecords",
        "propertyName": "_LIMIT_RECORDS_",
        "propertyType": "text",
        "tooltip": "Limit the records obtained on each batch",
        "qa": "fragment-details-crossdata-limitRecords"
      },
      {
        "propertyId": "offsetField",
        "propertyName": "_OFFSET_FILED_",
        "propertyType": "text",
        "required": true,
        "tooltip": "Offset field in the source table",
        "qa": "fragment-details-crossdata-offsetField"
      },
      {
        "propertyId": "offsetOperator",
        "propertyName": "_OFFSET_OPERATOR_",
        "propertyType": "select",
        "required": true,
        "values": [
          {
            "label": ">",
            "value": ">"
          },
          {
            "label": ">=",
            "value": ">="
          },
          {
            "label": "<",
            "value": "<"
          },
          {
            "label": "<=",
            "value": "<="
          }
        ],
        "default": ">=",
        "tooltip": "Offset operator to generate incremental or decremental queries in the source table",
        "qa": "fragment-details-crossdata-offsetOperator"
      },
      {
        "propertyId": "offsetValue",
        "propertyName": "_OFFSET_VALUE_",
        "propertyType": "text",
        "tooltip": "Initial offset value",
        "qa": "fragment-details-crossdata-offsetValue"
      },
      {
        "propertyId": "offsetLocation",
        "propertyName": "_OFFSET_LOCATION_",
        "propertyType": "select",
        "values": [
          {
            "label": "Memory",
            "value": "MEMORY"
          },
          {
            "label": "Zookeeper",
            "value": "ZOOKEEPER"
          }
        ],
        "default": "MEMORY",
        "required": true,
        "tooltip": "Location where the offsets are saved",
        "qa": "fragment-details-crossdata-offsetLocation"
      },
      {
        "propertyId": "zookeeperConnection",
        "propertyName": "_ZOOKEEPER_CONNECTION_",
        "propertyType": "text",
        "visible": [
          [
            {
              "propertyId": "offsetLocation",
              "value": "ZOOKEEPER"
            }
          ]
        ],
        "tooltip": "Initial sentence executed by Crossdata Context",
        "qa": "fragment-details-crossdata-initialSentence"
      },
      {
        "propertyId": "zookeeperPath",
        "propertyName": "_ZOOKEEPER_PATH_",
        "propertyType": "text",
        "visible": [
          [
            {
              "propertyId": "offsetLocation",
              "value": "ZOOKEEPER"
            }
          ]
        ],
        "default": "/crossdata/offsets",
        "tooltip": "Path in Zookeeper where are storage the offsets",
        "qa": "fragment-details-crossdata-zookeeperPath"
      },
      {
        "propertyId": "rememberDuration",
        "propertyName": "_REMEMBER_DURATION_",
        "propertyType": "text",
        "tooltip": "Remember duration in milliseconds",
        "qa": "fragment-details-crossdata-rememberDuration"
      },
      {
        "propertyId": "initialSentence",
        "propertyName": "_INITIAL_SENTENCE_",
        "propertyType": "text",
        "with": 12,
        "tooltip": "Initial sentence executed by Crossdata Context",
        "qa": "fragment-details-crossdata-initialSentence"
      },
      {
        "propertyId": "fromBeginning",
        "propertyName": "_FROM_BEGINNING_",
        "propertyType": "boolean",
        "default": false,
        "visible": [
          [
            {
              "propertyId": "offsetLocation",
              "value": "ZOOKEEPER"
            }
          ]
        ],
        "tooltip": "Start the offsets from beginning on launch",
        "qa": "fragment-details-crossdata-fromBeginning"
      },
      {
        "propertyId": "forcedBeginning",
        "propertyName": "_FORCED_BEGINNING_",
        "propertyType": "boolean",
        "default": false,
        "visible": [
          [
            {
              "propertyId": "offsetLocation",
              "value": "ZOOKEEPER"
            },
            {
              "propertyId": "fromBeginning",
              "value": true
            }
          ]
        ],
        "tooltip": "Force on start to assign the offsets from beginning",
        "qa": "fragment-details-crossdata-forcedBeginning"
      },
      {
        "propertyId": "finishAppWhenEmpty",
        "propertyName": "_FINISH_APP_WHEN_EMPTY_",
        "propertyType": "boolean",
        "default": false,
        "tooltip": "Stop the streaming context when the resulted query don't have data If enable simulate finite processes and disable infinite processes",
        "qa": "fragment-details-crossdata-stopWhenEmpty"
      },
      {
        "propertyId": "stopContexts",
        "propertyName": "_STOP_CONTEXTS_WHEN_EMPTY_",
        "propertyType": "boolean",
        "default": false,
        "tooltip": "Stop the Spark contexts on shutdown receiver",
        "qa": "fragment-details-crossdata-stopContextsWhenEmpty"
      },
      {
        "propertyId": "stopGracefully",
        "propertyName": "_STOP_GRACEFULLY_",
        "propertyType": "boolean",
        "visible": [
          [
            {
              "propertyId": "stopContexts",
              "value": true
            }
          ]
        ],
        "default": true,
        "tooltip": "Stop gracefully the streaming context",
        "qa": "fragment-details-crossdata-stopWhenEmpty"
      },
      {
        "propertyId": "tlsEnable",
        "propertyName": "_TLS_ENABLE_",
        "propertyType": "boolean",
        "tooltip": "Enable TLS connection to connect with extra security protocol than user and password",
        "default": false,
        "qa": "fragment-details-postgres-tls"
      },
      {
        "propertyId": "caName",
        "propertyName": "_CA_NAME_",
        "propertyType": "text",
        "width": 6,
        "visible": [
          [
            {
              "propertyId": "tlsEnable",
              "value": true
            }
          ]
        ],
        "default": "",
        "required": false,
        "tooltip": "CA name used in Spark nodes to get certificates from Vault",
        "qa": "fragment-details-postgres-ca-name"
      }
    ]
  }