  {
    "name": "Crossdata",
    "icon": "Crossdata",
    "className": "CrossdataInputStep",
    "classPrettyName": "Crossdata",
    "crossdataCatalog": true,
    "arity": ["NullaryToNary"],
    "supportedEngines": ["Streaming"],
    "supportedDataRelations": ["ValidData"],
    "description": "Allows you to load data from external Data Sources using Crossdata and to monitor tables migrating data in streaming processes with finite or infinite duration",
    "properties": [
      {
        "propertyId": "query",
        "propertyName": "_QUERY_",
        "propertyType": "textarea",
        "contentType": "SQL",
        "width": 12,
        "required": true,
        "tooltip": "Query to retrieve data from any temporal table available in the Crossdata catalog. The result will be stored in another temporal table named after the input step.",
        "placeholder": "select * from tableName",
        "qa": "fragment-details-crossdata-query"
      },
      {
        "propertyId": "storageLevel",
        "propertyName": "_STORAGELEVEL_",
        "propertyType": "select",
        "required": true,
        "default": "MEMORY_ONLY_SER",
        "tooltip": "Default Storage Level assigned to Spark Streaming batches. Refer to the Spark documentation for further information on this matter.",
        "qa": "policy-storage-level",
        "values": [
          {
            "label": "DISK_ONLY",
            "value": "DISK_ONLY"
          },
          {
            "label": "DISK_ONLY_2",
            "value": "DISK_ONLY_2"
          },
          {
            "label": "MEMORY_ONLY",
            "value": "MEMORY_ONLY"
          },
          {
            "label": "MEMORY_ONLY_2",
            "value": "MEMORY_ONLY_2"
          },
          {
            "label": "MEMORY_ONLY_SER",
            "value": "MEMORY_ONLY_SER"
          },
          {
            "label": "MEMORY_ONLY_SER_2",
            "value": "MEMORY_ONLY_SER_2"
          },
          {
            "label": "MEMORY_AND_DISK",
            "value": "MEMORY_AND_DISK"
          },
          {
            "label": "MEMORY_AND_DISK_2",
            "value": "MEMORY_AND_DISK_2"
          },
          {
            "label": "MEMORY_AND_DISK_SER",
            "value": "MEMORY_AND_DISK_SER"
          },
          {
            "label": "MEMORY_AND_DISK_SER_2",
            "value": "MEMORY_AND_DISK_SER_2"
          }
        ]
      },
      {
        "propertyId": "limitRecords",
        "propertyName": "_LIMIT_RECORDS_",
        "propertyType": "text",
         "tooltip": "Limit the records processed on each streaming window.",
         "qa": "fragment-details-crossdata-limitRecords"
      },
       {
          "propertyId": "offsetFields",
          "propertyName": "_OFFSET_FIELDS_",
          "propertyType": "list",
          "required": false,
          "tooltip": "List of fields used as offsets in the source table.",
          "qa": "fragment-details-datetime-fields",
          "fields": [
             {
                "propertyId": "offsetField",
                "propertyName": "_OFFSET_FILED_",
                "propertyType": "text",
                "required": true,
                "width": 4,
                "tooltip": "Offset field in the source table",
                "qa": "fragment-details-crossdata-offsetField"
             },
             {
                "propertyId": "offsetValue",
                "propertyName": "_OFFSET_VALUE_",
                "propertyType": "text",
                "width": 4,
                "tooltip": "Initial offset value",
                "qa": "fragment-details-crossdata-offsetValue"
             },
             {
                "propertyId": "offsetOperator",
                "propertyName": "_OFFSET_OPERATOR_",
                "propertyType": "select",
                "required": true,
                "width": 3,
                "values": [
                   {
                      "label": ">",
                      "value": ">"
                   },
                   {
                      "label": ">=",
                      "value": ">="
                   },
                   {
                      "label": "<",
                      "value": "<"
                   },
                   {
                      "label": "<=",
                      "value": "<="
                   }
                ],
                "default": ">=",
                "tooltip": "Offset operator to generate incremental or decremental queries in the source table",
                "qa": "fragment-details-crossdata-offsetOperator"
             }
          ]
       },
      {
        "propertyId": "offsetLocation",
        "propertyName": "_OFFSET_LOCATION_",
        "propertyType": "select",
        "values": [
          {
            "label": "Memory",
            "value": "MEMORY"
          },
          {
            "label": "Zookeeper",
            "value": "ZOOKEEPER"
          }
        ],
        "default": "MEMORY",
        "required": false,
        "tooltip": "Location where the offsets are saved",
        "qa": "fragment-details-crossdata-offsetLocation"
      },
      {
        "propertyId": "zookeeperConnection",
        "propertyName": "_ZOOKEEPER_CONNECTION_",
        "propertyType": "text",
        "visible": [
          [
            {
              "propertyId": "offsetLocation",
              "value": "ZOOKEEPER"
            }
          ]
        ],
         "default": "{{{CROSSDATA_ZOOKEEPER_CONNECTION}}}",
         "tooltip": "Zookeeper connection string",
        "qa": "fragment-details-crossdata-initialSentence"
      },
       {
          "propertyId": "zookeeperPath",
          "propertyName": "_ZOOKEEPER_PATH_",
          "propertyType": "text",
          "visible": [
             [
                {
                   "propertyId": "offsetLocation",
                   "value": "ZOOKEEPER"
                }
             ]
          ],
          "default": "{{{CROSSDATA_ZOOKEEPER_PATH}}}",
          "tooltip": "Path in Zookeeper where the offsets are allocated.",
          "qa": "fragment-details-crossdata-zookeeperPath"
       },
       {
          "propertyId": "resetOffsetOnStart",
          "propertyName": "_RESET_ON_START_",
          "propertyType": "boolean",
          "default": false,
          "visible": [
             [
                {
                   "propertyId": "offsetLocation",
                   "value": "ZOOKEEPER"
                }
             ]
          ],
          "tooltip": "If checked, the application will reset any stored offsets when starting the streaming process.",
          "qa": "fragment-details-crossdata-resetOffsetOnStart"
       },
       {
          "propertyId": "ignoreStartedStatus",
          "propertyName": "_IGNORE_STARTED_STATUS_",
          "propertyType": "boolean",
          "default": false,
          "visible": [
             [
                {
                   "propertyId": "offsetLocation",
                   "value": "ZOOKEEPER"
                },
                {
                   "propertyId": "resetOffsetOnStart",
                   "value": true
                }
             ]
          ],
          "tooltip": "Force the offsets reset ignoring the workflow status. If not checked, the offsets will be restarted only when the workflow status is set to 'Not started'.",
          "qa": "fragment-details-crossdata-ignoreStartedStatus"
       },
      {
        "propertyId": "stopContexts",
        "propertyName": "_STOP_CONTEXTS_WHEN_EMPTY_",
        "propertyType": "boolean",
        "default": false,
         "float": "true",
         "width": 4,
        "tooltip": "Allows the application to stop the Spark contexts after waiting for the processing of all received data to be completed",
        "qa": "fragment-details-crossdata-stopContextsWhenEmpty"
      },
       {
          "propertyId": "finishAppWhenEmpty",
          "propertyName": "_FINISH_APP_WHEN_EMPTY_",
          "propertyType": "boolean",
          "default": false,
          "width": 4,
          "tooltip": "If checked the application will shut down itself when no more data if left to be processed. It simulates a finite batch.",
          "qa": "fragment-details-crossdata-stopWhenEmpty"
       },
      {
        "propertyId": "tlsEnabled",
        "propertyName": "_TLS_ENABLE_",
        "propertyType": "boolean",
        "tooltip": "Enable TLS protocol in order to connect to a secured Crossdata catalog using certificates",
        "default": false,
        "qa": "fragment-details-postgres-tls"
      }
    ]
  }
