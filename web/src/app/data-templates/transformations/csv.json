{
   "name": "Csv",
   "icon": "Csv",
   "category": "Row",
   "className": "CsvTransformStep",
   "classPrettyName": "Csv",
   "arity": [
      "UnaryToNary"
   ],
   "supportedEngines": [
      "Streaming",
      "Batch"
   ],
   "supportedDataRelations": [
      "ValidData",
      "DiscardedData"
   ],
   "description": "Parses an input field with CSV format and returns all the obtained new fields or selected ones.",
   "properties": [
      {
         "propertyId": "inputField",
         "propertyName": "_INPUT_FIELD_",
         "propertyType": "text",
         "showSchemaFields": true,
         "required": true,
         "tooltip": "Field containing the CSV string.",
         "qa": "fragment-details-csv-fieldsString"
      },
      {
         "propertyId": "fieldsPreservationPolicy",
         "propertyName": "_FIELDS_PRESERVATION_",
         "required": true,
         "propertyType": "select",
         "default": "REPLACE",
         "values": [
            {
               "label": "Replacing input field",
               "value": "REPLACE"
            },
            {
               "label": "Appending extracted",
               "value": "APPEND"
            },
            {
               "label": "Keeping just extracted",
               "value": "JUST_EXTRACTED"
            }
         ],
         "tooltip": "If 'Replacing input field' is chosen, the resulting data will be saved in the position occupied by the input field. 'Appending extracted' will add the data at the end of the row while 'Keeping just extracted' will only keep the transformed data discarding the received.",
         "qa": "workflow-transformation-csv-fieldsPreservationPolicy"
      },
      {
         "propertyId": "schema.inputMode",
         "propertyName": "_INPUT_SCHEMA_FROM_",
         "propertyType": "select",
         "required": true,
         "values": [
            {
               "label": "Header",
               "value": "HEADER"
            },
            {
               "label": "Fields",
               "value": "FIELDS"
            },
            {
               "label": "Spark format",
               "value": "SPARKFORMAT"
            }
         ],
         "default": "HEADER",
         "tooltip": "Specifies whether to generate the schema either by looking at the header or at the fields property or by reading a user-provided Spark format string.",
         "qa": "fragment-details-input-schema-type"
      },
      {
         "propertyId": "schema.header",
         "propertyName": "_HEADER_",
         "propertyType": "textarea",
         "contentType": "JSON",
         "width": 12,
         "visible": [
            [
               {
                  "propertyId": "schema.inputMode",
                  "value": "HEADER"
               }
            ]
         ],
         "required": true,
         "tooltip": "Header with the fields names",
         "qa": "fragment-details-csv-header"
      },
      {
         "propertyId": "headerRemoval",
         "propertyName": "_HEADER_REMOVAL_",
         "propertyType": "boolean",
         "required": true,
         "default": false,
         "tooltip": "If checked, the provided header will be removed from the input file",
         "qa": "workflow-transformation-json-header-removal"
      },
      {
         "propertyId": "schema.fields",
         "propertyName": "_FIELDS_DEFINITION_",
         "propertyType": "list",
         "visible": [
            [
               {
                  "propertyId": "schema.inputMode",
                  "value": "FIELDS"
               }
            ]
         ],
         "required": true,
         "tooltip": "Schema definition from list of fields",
         "qa": "fragment-details-csv-fields",
         "fields": [
            {
               "propertyId": "name",
               "propertyName": "_NAME_",
               "propertyType": "text",
               "required": true,
               "width": 4,
               "qa": "fragment-details-field-name"
            },
            {
               "propertyId": "type",
               "propertyName": "_TYPE_",
               "propertyType": "select",
               "custom": true,
               "required": true,
               "width": 4,
               "values": [
                  {
                     "label": "String",
                     "value": "string"
                  },
                  {
                     "label": "Long",
                     "value": "long"
                  },
                  {
                     "label": "Float",
                     "value": "float"
                  },
                  {
                     "label": "Double",
                     "value": "double"
                  },
                  {
                     "label": "Integer",
                     "value": "integer"
                  },
                  {
                     "label": "Boolean",
                     "value": "boolean"
                  },
                  {
                     "label": "Binary",
                     "value": "binary"
                  },
                  {
                     "label": "Date",
                     "value": "date"
                  },
                  {
                     "label": "Timestamp",
                     "value": "timestamp"
                  },
                  {
                     "label": "Array(Double)",
                     "value": "arraydouble"
                  },
                  {
                     "label": "Array(String)",
                     "value": "arraystring"
                  },
                  {
                     "label": "Array(Long)",
                     "value": "arraylong"
                  },
                  {
                     "label": "Array(Integer)",
                     "value": "arrayinteger"
                  },
                  {
                     "label": "Array(Map(String, String))",
                     "value": "arraymapstringstring"
                  },
                  {
                     "label": "Map(String, Long)",
                     "value": "mapstringlong"
                  },
                  {
                     "label": "Map(String, Double)",
                     "value": "mapstringdouble"
                  },
                  {
                     "label": "Map(String, Integer)",
                     "value": "mapstringint"
                  },
                  {
                     "label": "Map(String, String)",
                     "value": "mapstringstring"
                  }
               ],
               "default": "string",
               "qa": "fragment-details-field-type"
            },
            {
               "propertyId": "nullable",
               "propertyName": "_NULLABLE_",
               "propertyType": "boolean",
               "default": true,
               "required": true,
               "qa": "fragment-details-field-nullable"
            }
         ]
      },
      {
         "propertyId": "schema.sparkSchema",
         "propertyName": "_SPARK_SCHEMA_",
         "propertyType": "textarea",
         "contentType": "JSON",
         "width": 12,
         "visible": [
            [
               {
                  "propertyId": "schema.inputMode",
                  "value": "SPARKFORMAT"
               }
            ]
         ],
         "required": true,
         "tooltip": "Spark schema defining all the fields in the CSV",
         "qa": "fragment-details-csv-spark-schema"
      },
      {
         "propertyId": "delimiter",
         "propertyName": "_DELIMITER_",
         "propertyType": "text",
         "required": true,
         "default": "{{{Global.DEFAULT_DELIMITER}}}",
         "tooltip": "Delimiter character used to parse the CSV string",
         "qa": "fragment-details-csv-delimiter"
      },
      {
         "propertyId": "splitLimit",
         "propertyName": "_SPLIT_LIMIT_",
         "propertyType": "text",
         "required": true,
         "default": "-1",
         "tooltip": "Determines the number of results obtained from parsing. If set to -1 no limit will be specified.",
         "qa": "fragment-details-csv-splitLimit"
      },
      {
         "propertyId": "delimiterType",
         "propertyName": "_DELIMITER_TYPE_",
         "propertyType": "select",
         "default": "CHARACTER",
         "required": true,
         "values": [
            {
               "label": "Character",
               "value": "CHARACTER"
            },
            {
               "label": "Regex",
               "value": "REGEX"
            }
         ],
         "qa": "workflow-transformation-csv-delimiterType"
      },
      {
         "propertyId": "inputSchemas",
         "propertyName": "_INPUTS_TRIGGER_SCHEMA_",
         "propertyType": "list",
         "required": false,
         "complexForm": true,
         "tooltip": "Section that allows the user to define incoming steps schemas. Once defined properly, the schema calculation for all incoming inputs will be avoided thus increasing the workflow performance and type-safety.",
         "qa": "fragment-details-schema-fields",
         "fields": [
            {
               "propertyId": "stepName",
               "propertyName": "_INPUT_STEP_NAME_",
               "propertyType": "text",
               "showInputSteps": true,
               "required": true,
               "tooltip": "Incoming step name.",
               "width": 8,
               "float": false,
               "qa": "fragment-details-field-name"
            },
            {
               "propertyId": "schema",
               "propertyName": "_DESERIALIZER_SCHEMA_",
               "propertyType": "textarea",
               "contentType": "JSON",
               "width": 12,
               "tooltip": "Input schema either expressed in JSON/Spark format or by providing a valid sample.",
               "required": true,
               "qa": "fragment-details-field-query"
            }
         ]
      },
      {
         "propertyId": "whenRowError",
         "propertyName": "_TRANSFORMATION_WHEN_ROW_ERROR_",
         "propertyType": "select",
         "values": [
            {
               "label": "Error",
               "value": "RowError"
            },
            {
               "label": "Discard",
               "value": "RowDiscard"
            }
         ],
         "tooltip": "Specifies which policy to follow when a row-level error arises. If 'Error' is chosen, the application will stop and the error trace will be written to the log. If 'Discard' is chosen, no error will be prompted and the row will be omitted.",
         "qa": "workflow-transformation-whenRowError"
      },
      {
         "propertyId": "whenFieldError",
         "propertyName": "_TRANSFORMATION_WHEN_FIELD_ERROR_",
         "propertyType": "select",
         "values": [
            {
               "label": "Error",
               "value": "FieldError"
            },
            {
               "label": "Null",
               "value": "Null"
            }
         ],
         "tooltip": "Specifies which policy to follow when a field-level error arises. If 'Error' is chosen, the application will stop and the error trace will be written to the log. If 'Null' is chosen, no error will be prompted and the field value will be set to null.",
         "qa": "workflow-transformation-whenFieldError"
      }
   ]
}
