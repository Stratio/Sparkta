# API
sparta.api.host = 0.0.0.0
sparta.api.host = ${?SPARTA_API_HOST}
sparta.api.port = 9090
sparta.api.port = ${?PORT_SPARTAAPI}
sparta.api.certificate-file = "/home/user/certifications/stratio.jks"
sparta.api.certificate-file = ${?SPARTA_TLS_KEYSTORE_LOCATION}
sparta.api.certificate-password = "stratio"
sparta.api.certificate-password = ${?SPARTA_TLS_KEYSTORE_PASSWORD}

# SECURITY
sparta.ssl.truststore.location = ${?SPARTA_TLS_TRUSTSTORE_LOCATION}
sparta.ssl.truststore.password = ${?SPARTA_TLS_TRUSTSTORE_PASSWORD}
sparta.ssl.keystore.location = ${?SPARTA_TLS_KEYSTORE_LOCATION}
sparta.ssl.keystore.password = ${?SPARTA_TLS_KEYSTORE_PASSWORD}

# SSH
sparta.ssl.pem.location = ${?SPARTA_PEM_LOCATION}
sparta.ssl.pem.key.location = ${?SPARTA_PEM_KEY_LOCATION}

# SPRAY
spray.can.server.ssl-encryption = "off"
spray.can.server.request-timeout = 20s
spray.can.server.idle-timeout = 60s
spray.can.server.idle-timeout = ${?SPARTA_API_IDLE_TIMEOUT}
spray.can.parsing.max-content-length = 150m
spray.can.parsing.max-content-length = ${?SPARTA_API_MAX_FILE_SIZE_UPLOAD}
spray.can.parsing.max-chunk-size = 1m
spray.can.parsing.max-chunk-size = ${?SPARTA_API_MAX_CHUNK_SIZE}
#SPRAY_CAN_EXTRA_PROPERTIES

# OAUTH2
oauth2.enable = "false"
oauth2.enable = ${?OAUTH2_ENABLE}
oauth2.cookieName = "user"
oauth2.cookieName = ${?OAUTH2_COOKIE_NAME}
oauth2.url.authorize = "https://server.domain:9005/cas/oauth2.0/authorize"
oauth2.url.authorize = ${?OAUTH2_SSL_AUTHORIZE}
oauth2.url.accessToken = "https://server.domain:9005/cas/oauth2.0/accessToken"
oauth2.url.accessToken = ${?OAUTH2_URL_ACCESS_TOKEN}
oauth2.url.profile = "https://server.domain:9005/cas/oauth2.0/profile"
oauth2.url.profile = ${?OAUTH2_URL_PROFILE}
oauth2.url.logout = "https://server.domain:9005/cas/logout"
oauth2.url.logout = ${?OAUTH2_URL_LOGOUT}
oauth2.url.callBack = "http://callback.domain:9090/login"
oauth2.url.callBack = ${?OAUTH2_URL_CALLBACK}
oauth2.url.onLoginGoTo = "/"
oauth2.url.onLoginGoTo = ${?OAUTH2_URL_ON_LOGIN_GO_TO}
oauth2.client.id = "userid"
oauth2.client.id = ${?OAUTH2_CLIENT_ID}
oauth2.client.secret = "usersecret"
oauth2.client.secret = ${?OAUTH2_CLIENT_SECRET}
#OAUTH2_EXTRA_PROPERTIES

# HEADERS_AUTH
sparta.authWithHeaders.enabled = false
sparta.authWithHeaders.enabled = ${?SPARTA_AUTHVIAHEADERS_ENABLED}
sparta.authWithHeaders.user = "USER_HEADER"
sparta.authWithHeaders.user = ${?SPARTA_AUTHVIAHEADERS_HEADER_USER}
sparta.authWithHeaders.group = "GROUP_HEADER"
sparta.authWithHeaders.group = ${?SPARTA_AUTHVIAHEADERS_HEADER_GROUP}

# ZOOKEEPER
sparta.zookeeper.connectionString = "localhost:2181"
sparta.zookeeper.connectionString = ${?SPARTA_ZOOKEEPER_CONNECTION_STRING}
sparta.zookeeper.storagePath = "/stratio/sparta"
sparta.zookeeper.storagePath = ${?SPARTA_ZOOKEEPER_PATH}
sparta.zookeeper.connectionTimeout = 19000
sparta.zookeeper.connectionTimeout = ${?SPARTA_ZOOKEEPER_CONNECTION_TIMEOUT}
sparta.zookeeper.sessionTimeout = 60000
sparta.zookeeper.sessionTimeout = ${?SPARTA_ZOOKEEPER_SESSION_TIMEOUT}
sparta.zookeeper.retryAttempts = 5
sparta.zookeeper.retryAttempts = ${?SPARTA_ZOOKEEPER_RETRY_ATEMPTS}
sparta.zookeeper.retryInterval = 10000
sparta.zookeeper.retryInterval = ${?SPARTA_ZOOKEEPER_RETRY_INTERVAL}
#SPARTA_ZOOKEEPER_EXTRA_PROPERTIES

# AKKA
akka.log-dead-letters = off
akka.loggers = ["akka.event.slf4j.Slf4jLogger"]
akka.logger-startup-timeout = 30s
akka.persistence.journal.plugin = "akka.persistence.journal.leveldb"
akka.persistence.snapshot-store.plugin = "akka.persistence.snapshot-store.local"
akka.persistence.journal.leveldb.dir = "./persistence/journal"
akka.persistence.snapshot-store.local.dir = "./persistence/snapshots"
akka.extensions = ["com.romix.akka.serialization.kryo.KryoSerializationExtension$"]
akka.actor.serializers.kryo = "com.romix.akka.serialization.kryo.KryoSerializer"
akka.actor.serializers.java = "akka.serialization.JavaSerializer"
akka.actor.serialization-bindings {
  "java.io.Serializable" = java
  #"com.stratio.sparta.classToSerialize" = kryo
}
akka.actor.kryo.type = "nograph"
akka.actor.kryo.idstrategy = "automatic"
akka.actor.kryo.buffer-size = 65536
akka.actor.kryo.kyro-trace = false
akka.actor.kryo.resolve-subclasses = true
#AKKA_EXTRA_PROPERTIES

# AKKA EXECUTION CONTEXT DISPATCHER
sparta-actors-dispatcher.type = Dispatcher
sparta-actors-dispatcher.executor = "fork-join-executor"
sparta-actors-dispatcher.fork-join-executor.parallelism-min = 4
sparta-actors-dispatcher.fork-join-executor.parallelism-min = ${?SPARTA_ACTORS_DISPATCHER_PARALELLISM_MIN}
sparta-actors-dispatcher.fork-join-executor.parallelism-factor = 4.0
sparta-actors-dispatcher.fork-join-executor.parallelism-factor = ${?SPARTA_ACTORS_DISPATCHER_PARALELLISM_FACTOR}
sparta-actors-dispatcher.fork-join-executor.parallelism-max = 128
sparta-actors-dispatcher.fork-join-executor.parallelism-max = ${?SPARTA_ACTORS_DISPATCHER_PARALELLISM_MAX}
sparta-actors-dispatcher.throughput = 256
sparta-actors-dispatcher.throughput = ${?SPARTA_ACTORS_DISPATCHER_THROUGHPUT}
#SPARTA_ACTOR_DISPATCHER_EXTRA_PROPERTIES

# AKKA HTTP
akka.http.host-connection-pool.max-connections = 32
akka.http.host-connection-pool.max-connections = ${?SPARTA_ACTORS_HTTP_MAX_CONNECTIONS}
akka.http.host-connection-pool.max-open-requests = 256
akka.http.host-connection-pool.max-open-requests = ${?SPARTA_ACTORS_HTTP_MAX_OPEN_REQUESTS}

# AKKA STREAMS
akka.stream.materializer.initial-input-buffer-size = 32
akka.stream.materializer.initial-input-buffer-size = ${?SPARTA_ACTORS_STREAM_INITIAL_INPUT_BUFFER_SIZE}
akka.stream.materializer.max-input-buffer-size = 128
akka.stream.materializer.max-input-buffer-size = ${?SPARTA_ACTORS_STREAM_MAX_INPUT_BUFFER_SIZE}

# AKKA CLUSTER PROPERTIES
clusterSparta.akka.extensions = ["com.romix.akka.serialization.kryo.KryoSerializationExtension$", "akka.cluster.pubsub.DistributedPubSub"]
clusterSparta.akka.actor.serialization-bindings {
  "java.io.Serializable" = java
  "akka.cluster.ClusterMessage" = akka-cluster
}
clusterSparta.akka.actor.kryo.type = "nograph"
clusterSparta.akka.actor.kryo.idstrategy = "automatic"
clusterSparta.akka.actor.kryo.buffer-size = 65536
clusterSparta.akka.actor.kryo.kyro-trace = false
clusterSparta.akka.actor.kryo.resolve-subclasses = true
#AKKA CLUSTER
clusterSparta.akka.actor.provider = "cluster"
clusterSparta.akka.remote.log-remote-lifecycle-events = on
clusterSparta.akka.remote.netty.tcp.hostname = "127.0.0.1"
clusterSparta.akka.remote.netty.tcp.hostname = ${?SPARTA_AKKA_HOST}
clusterSparta.akka.remote.netty.tcp.port = 10000
clusterSparta.akka.remote.netty.tcp.port = ${?PORT_AKKASEED}
clusterSparta.akka.remote.netty.tcp.bind-hostname = "127.0.0.1"
clusterSparta.akka.remote.netty.tcp.bind-hostname = ${?SPARTA_AKKA_BIND_HOST}
clusterSparta.akka.remote.netty.tcp.bind-port = 10000
clusterSparta.akka.remote.netty.tcp.bind-port = ${?PORT_AKKASEED}
clusterSparta.akka.cluster.roles = ["spartaMaster"]
clusterSparta.actor.deployment.default.cluster.use-roles = ["spartaMaster"]
clusterSparta.akka.cluster.min-nr-of-members = 1
clusterSparta.akka.cluster.min-nr-of-members = ${?SPARTA_AKKA_MIN_NUMBER}
clusterSparta.akka.cluster.role.spartaMaster.min-nr-of-members = 1
clusterSparta.akka.cluster.role.spartaMaster.min-nr-of-members = ${?SPARTA_AKKA_MIN_ROLE_NUMBER}
clusterSparta.akka.cluster.seed-node-timeout = 20s
clusterSparta.akka.cluster.seed-node-timeout = ${?SPARTA_AKKA_SEED_TIMEOUT}
clusterSparta.akka.cluster.retry-unsuccessful-join-after = 20s
clusterSparta.akka.cluster.retry-unsuccessful-join-after = ${?SPARTA_AKKA_RETRY_UNSUCCESSFUL_JOIN_AFTER}
#FailureDetector
# The default PhiAccrualFailureDetector will trigger if there are no heartbeats within
# the duration heartbeat-interval + acceptable-heartbeat-pause + threshold = 8,
# i.e. around 5.5 seconds with default settings.
clusterSparta.akka.cluster.failure-detector.threshold = 12
clusterSparta.akka.cluster.failure-detector.threshold = ${?SPARTA_AKKA_FAILURE_DETECTOR_THRESHOLD}
clusterSparta.akka.cluster.heartbeat-interval = 6s
clusterSparta.akka.cluster.heartbeat-interval = ${?SPARTA_AKKA_FAILURE_DETECTOR_HEARTBEAT_INTERVAL}
clusterSparta.akka.cluster.acceptable-heartbeat-pause = 20s
clusterSparta.akka.cluster.acceptable-heartbeat-pause = ${?SPARTA_AKKA_ACCEPTABLE_HEARTBEAT_PAUSE}
#SHUTDOWN
//Si no se conecta al cluster este nodo se mata
# The joining of given seed nodes will by default be retried indefinitely until
# a successful join. That process can be aborted if unsuccessful by defining this
# timeout. When aborted it will run CoordinatedShutdown, which by default will
# terminate the ActorSystem. CoordinatedShutdown can also be configured to exit
# the JVM. It is useful to define this timeout if the seed-nodes are assembled
# dynamically and a restart with new seed-nodes should be tried after unsuccessful
# attempts.
clusterSparta.akka.cluster.shutdown-after-unsuccessful-join-seed-nodes = 240s
clusterSparta.akka.cluster.shutdown-after-unsuccessful-join-seed-nodes = ${?SPARTA_AKKA_GRACEPERIODS_SECONDS}
clusterSparta.cluster-io-dispatcher.type = Dispatcher
clusterSparta.cluster-io-dispatcher.executor = "thread-pool-executor"
clusterSparta.cluster-io-dispatcher.thread-pool-executor.fixed-pool-size = 32
clusterSparta.cluster-io-dispatcher.throughput = 1
#AKKA_CLUSTER_EXTRA_PROPERTIES

# CONFIG
sparta.config.version = ${pom.version}
sparta.config.actors.instances = 4
sparta.config.actors.instances = ${?SPARTA_CONFIG_ACTORS_INSTANCES}
sparta.config.driverLocation = "/opt/sds/sparta/driver/sparta-driver.jar"
sparta.config.driverPackageLocation = "/tmp/sparta/driver"
sparta.config.driverPackageLocation = ${?SPARTA_CONFIG_DRIVER_PACKAGE_LOCATION}
sparta.config.pluginsLocation = "plugins"
sparta.config.pluginsLocation = ${?SPARTA_CONFIG_PLUGIN_PACKAGE_LOCATION}
sparta.config.backupsLocation = "/tmp/sparta/backups"
sparta.config.backupsLocation = ${?SPARTA_CONFIG_BACKUP_LOCATION}
sparta.config.timeout = 20
sparta.config.timeout = ${?SPARTA_TIMEOUT_API_CALLS}
sparta.config.lineage.enable = false
sparta.config.lineage.enable = ${?LINEAGE_ENABLE}
sparta.config.metrics.jmx.enable = false
sparta.config.metrics.jmx.enable = ${?JMX_METRICS_ENABLE}
sparta.config.metrics.prometheus.enable = true
sparta.config.metrics.prometheus.enable = ${?PROMETHEUS_METRICS_ENABLE}
sparta.config.user.metrics.enable = false
sparta.config.user.metrics.enable = ${?USER_METRICS_ENABLE}
sparta.config.marathon.checkInterval = "1m"
sparta.config.marathon.checkInterval = ${?SPARTA_MARATHON_CHECK_CONSISTENCY_INTERVAL}
sparta.config.migration.enable = true
sparta.config.migration.enable = ${?SPARTA_MIGRATION_ENABLE}
sparta.config.scheduler.stop.maxCount = 3
sparta.config.scheduler.stop.maxCount = ${?SPARTA_SCHEDULER_STOP_MAX_COUNT}
sparta.config.internal.domain = "paas.labs.stratio.com"
sparta.config.internal.domain = ${?EOS_INTERNAL_DOMAIN}
sparta.config.workflow.scheduler.delay = 10
sparta.config.workflow.scheduler.delay = ${?SPARTA_WORKFLOW_SCHEDULER_DELAY}
#SPARTA_CONFIG_EXTRA_PROPERTIES

# POSTGRES
sparta.postgres.host="localhost:5432"
sparta.postgres.host=${?SPARTA_POSTGRES_HOST}
sparta.postgres.database="postgres"
sparta.postgres.database=${?SPARTA_POSTGRES_DATABASE}
sparta.postgres.extraParams="prepareThreshold=0&leakDetectionThreshold=10000"
sparta.postgres.extraParams=${?SPARTA_POSTGRES_EXTRAPARAMS}
sparta.postgres.schemaName="sparta"
sparta.postgres.schemaName=${?SPARTA_POSTGRES_SCHEMA_NAME}
sparta.postgres.user="postgres"
sparta.postgres.user=${?SPARTA_POSTGRES_USER}
sparta.postgres.driver = org.postgresql.Driver
sparta.postgres.sslenabled = false
sparta.postgres.sslenabled = ${?SECURITY_TLS_ENABLE}
sparta.postgres.sslcert = ${?SPARTA_TLS_CERT}
sparta.postgres.sslkey = ${?SPARTA_TLS_KEY_PKCS8}
sparta.postgres.sslrootcert = ${?SPARTA_TLS_ROOTCERT}
#SPARTA_POSTGRES_EXTRA_PROPERTIES

# Slick
sparta.postgres.numThreads = 8
sparta.postgres.numThreads = ${?SPARTA_POSTGRES_POOL_THREADS}
sparta.postgres.queueSize = 3000
sparta.postgres.queueSize = ${?SPARTA_POSTGRES_POOL_QUEUE_SIZE}
sparta.postgres.executionContext.parallelism = 64
sparta.postgres.executionContext.parallelism = ${?SPARTA_POSTGRES_EXECUTION_CONTEXT_PARALLELISM}
sparta.postgres.keepAliveConnection = false
sparta.postgres.keepAliveConnection = ${?SPARTA_POSTGRES_KEEP_ALIVE}

# HikariCP
sparta.postgres.connectionPool = "HikariCP"
sparta.postgres.poolName =  "spartaPostgresPool"
sparta.postgres.initializationFailFast = true
sparta.postgres.initializationFailFast = ${?SPARTA_POSTGRES_POOL_INITIALIZATION_FAIL_FAST}
sparta.postgres.leakDetectionThreshold = 10000
sparta.postgres.leakDetectionThreshold= ${?SPARTA_POSTGRES_POOL_LEAK_DETECTION_THRESHOLD}
sparta.postgres.maxConnections = 8
sparta.postgres.maxConnections = ${?SPARTA_POSTGRES_POOL_MAX_CONNECTIONS}
sparta.postgres.minConnections = 8
sparta.postgres.minConnections = ${?SPARTA_POSTGRES_POOL_MIN_CONECTIONS}
sparta.postgres.connectionTimeout = 20000
sparta.postgres.connectionTimeout = ${?SPARTA_POSTGRES_POOL_CONNECTION_TIMEOUT}
sparta.postgres.validationTimeout = 3000
sparta.postgres.validationTimeout = ${?SPARTA_POSTGRES_POOL_VALIDATION_TIMEOUT}


# IGNITE
sparta.ignite.enabled = false
sparta.ignite.enabled = ${?SPARTA_IGNITE_ENABLED}
sparta.ignite.instance.name = "sparta-ignite-instance"
sparta.ignite.instance.name = ${?SPARTA_IGNITE_INSTANCE_NAME}
sparta.ignite.cache.name = "sparta-cache"
sparta.ignite.cache.name = ${?SPARTA_IGNITE_CACHE_NAME}
sparta.ignite.security.enabled = false
sparta.ignite.security.enabled = ${?SECURITY_TLS_ENABLE}
sparta.ignite.cluster.enabled = true
sparta.ignite.cluster.enabled = ${?SPARTA_IGNITE_CLUSTER_ENABLED}
sparta.ignite.memory.initialSizeMB = 128
sparta.ignite.memory.initialSizeMB = ${?SPARTA_IGNITE_MEM_INITIAL_SIZE}
sparta.ignite.memory.maxSizeMB = 256
sparta.ignite.memory.maxSizeMB = ${?SPARTA_IGNITE_MEM_MAX_SIZE}
sparta.ignite.communication.spiAddress = "127.0.0.1"
sparta.ignite.communication.spiAddress = ${?SPARTA_AKKA_HOST}
sparta.ignite.communication.spiPort = 11000
sparta.ignite.communication.spiPort = ${?PORT_SPIIGNITE}
sparta.ignite.communication.spiPortRange = 0
sparta.ignite.communication.spiPortRange = ${?SPARTA_IGNITE_SPI_PORT_RANGE}
sparta.ignite.persistence.enabled = false
sparta.ignite.persistence.enabled = ${?SPARTA_IGNITE_PERSISTENCE_ENABLED}
sparta.ignite.persistence.walPath = "/tmp/ignite/wal"
sparta.ignite.persistence.walPath = ${?SPARTA_IGNITE_PERSISTENCE_WAL}
sparta.ignite.persistence.persistencePath = "/tmp/ignite/persistence"
sparta.ignite.persistence.persistencePath = ${?SPARTA_IGNITE_PERSISTENCE_PATH}
#SPARTA_IGNITE_EXTRA_PROPERTIES

# INTELLIGENCE
sparta.intelligence.repository.url = "http://localhost:8000"
sparta.intelligence.repository.url = ${?INTELLIGENCE_URL}

# HDFS
# The hadoop user name could be configured by two ways:
# 1. Using the enviroment variable HADOOP_USER_NAME
# 2. Using the variable hadoopUserName from properties file
sparta.hdfs.hadoopUserName = ${?SPARTA_HADOOP_USER_NAME}
# If the variable HADOOP_CONF_DIR is not defined, "hdfsMaster" variable and "hdfsPort" are used to
# connect to HDFS cluster in order to upload jars to HDFS, but the Spark executors and the
# Spark driver need this environment variable defined. In producction environments is recomended use
# HADOOP_CONF_DIR because use HA in Hadoop Namenodes
sparta.hdfs.hdfsMaster = ${?HADOOP_FS_DEFAULT_NAME}
sparta.hdfs.hdfsPort = ${?HADOOP_PORT}
# Configuration to connect to HDFS Kerberized
# The principal name could be configured by two ways:
# 1. Using the enviroment variable SPARTA_PRINCIPAL_NAME
# 2. Using the variable principalName from properties file
# The principal name used to connect to HDFS securized have the order 1, 2
sparta.hdfs.principalName = ${?SPARTA_PRINCIPAL_NAME}
# The keytab path could be configured by two ways:
# 1. Using the enviroment variable SPARTA_KEYTAB_PATH
# 2. Using the variable keytabPath from properties file
sparta.hdfs.keytabPath = ${?SPARTA_KEYTAB_PATH}
sparta.hdfs.reloadKeyTab = ${?HDFS_KEYTAB_RELOAD}
sparta.hdfs.reloadKeyTabTime = ${?HDFS_KEYTAB_RELOAD_TIME}

# MARATHON
sparta.marathon.docker.image = "qa.stratio.com/stratio/sparta:2.5.0"
sparta.marathon.docker.image = ${?SPARTA_DOCKER_IMAGE}
sparta.marathon.docker.includeCommonVolumes = true
sparta.marathon.docker.includeCommonVolumes = ${?SPARTA_MARATHON_INCLUDE_COMMON_VOLUMES}
sparta.marathon.docker.includeCertVolumes = true
sparta.marathon.docker.includeCertVolumes = ${?SPARTA_MARATHON_INCLUDE_CERT_VOLUMES}
sparta.marathon.jar = "/opt/sds/sparta/driver/sparta-driver.jar"
sparta.marathon.jar = ${?SPARTA_MARATHON_JAR}
sparta.marathon.mesosphere.lib = "/opt/mesosphere/lib"
sparta.marathon.mesosphere.lib = ${?SPARTA_MARATHON_MESOSPHERE_LIB}
sparta.marathon.mesosphere.packages = "/opt/mesosphere/packages"
sparta.marathon.mesosphere.packages = ${?SPARTA_MARATHON_MESOSPHERE_PACKAGES}
sparta.marathon.sso.uri = ${?MARATHON_SSO_URI}
sparta.marathon.sso.trimUri = false
sparta.marathon.sso.trimUri = ${?MARATHON_SSO_TRIM_URI}
sparta.marathon.sso.username = ${?MARATHON_SSO_USERNAME}
sparta.marathon.sso.password = ${?MARATHON_SSO_PASSWORD}
sparta.marathon.sso.retries = ${?MARATHON_SSO_RETRIES}
sparta.marathon.uri = ${?MARATHON_TIKI_TAKKA_MARATHON_URI}
sparta.marathon.api.version = "v2"
sparta.marathon.api.version = ${?MARATHON_TIKI_TAKKA_MARATHON_API_VERSION}
#SPARTA_MARATHON_EXTRA_PROPERTIES

# CROSSDATA
crossdata.catalog.class = ${?CROSSDATA_CORE_CATALOG_CLASS}
crossdata.catalog.prefix = "crossdataCluster"
crossdata.catalog.prefix = ${?CROSSDATA_CORE_CATALOG_PREFIX}
crossdata.catalog.refresh-tables = false
crossdata.catalog.refresh-tables = ${?CROSSDATA_CORE_CATALOG_REFRESH_TABLES}
crossdata.catalog.refresh-time = 10m
crossdata.catalog.refresh-time = ${?CROSSDATA_CORE_CATALOG_REFRESH_TIME}
crossdata.catalog.cache-full = false
crossdata.catalog.cache-full = ${?CROSSDATA_CORE_CATALOG_CACHEFULL}
crossdata.catalog.cache-ttl = 60
crossdata.catalog.cache-ttl = ${?CROSSDATA_CORE_CATATALOG_CACHETTL}
crossdata.catalog.cache-enabled = false
crossdata.catalog.cache-enabled = ${?CROSSDATA_CORE_CATALOG_CACHE}
crossdata.catalog.hash-hidden-columns = false
crossdata.catalog.hash-hidden-columns = ${?CROSSDATA_CORE_CATALOG_HASH_HIDDEN_COLUMNS}
crossdata.catalog.hash-signature = ${?CROSSDATA_CORE_CATALOG_HASH_SIGNATURE}
crossdata.catalog.zookeeper.connectionString = "localhost:2181"
crossdata.catalog.zookeeper.connectionString = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_CONNECTIONSTRING}
crossdata.catalog.zookeeper.connectionTimeout = 15s
crossdata.catalog.zookeeper.connectionTimeout = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_CONNECTIONTIMEOUT}
crossdata.catalog.zookeeper.sessionTimeout = 60s
crossdata.catalog.zookeeper.sessionTimeout = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_SESSIONTIMEOUT}
crossdata.catalog.zookeeper.retryAttempts = 5
crossdata.catalog.zookeeper.retryAttempts = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_RETRYATTEMPTS}
crossdata.catalog.zookeeper.retryInterval = 10s
crossdata.catalog.zookeeper.retryInterval = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_RETRYINTERVAL}
crossdata.catalog.zookeeper.compatibilityWithStratioSecurityMode = false
crossdata.catalog.zookeeper.compatibilityWithStratioSecurityMode = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_COMPATIBILITY_WITH_SECURITY_MODE}
crossdata.catalog.zookeeper.cache = false
crossdata.catalog.zookeeper.cache = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_CACHE}
crossdata.catalog.postgres.url = "jdbc:postgresql://localhost:5432"
crossdata.catalog.postgres.url = ${?CROSSDATA_CORE_CATALOG_POSTGRES_URL}
crossdata.catalog.postgres.user = "postgres"
crossdata.catalog.postgres.user = ${?CROSSDATA_CORE_CATALOG_POSTGRES_USER}
crossdata.catalog.postgres.password = "postgres"
crossdata.catalog.postgres.password = ${?CROSSDATA_CORE_CATALOG_POSTGRES_PWD}
crossdata.catalog.postgres.stratioSecurity = false
crossdata.catalog.postgres.stratioSecurity = ${?CROSSDATA_CORE_CATALOG_POSTGRES_STRATIOSECURITY}
crossdata.catalog.postgres.stratioSecurityMode = "tls"
crossdata.catalog.postgres.stratioSecurityMode = ${?CROSSDATA_CORE_CATALOG_POSTGRES_STRATIOSECURITYMODE}
crossdata.catalog.postgres.timeout = 10s
crossdata.catalog.postgres.timeout = ${?CROSSDATA_CORE_CATALOG_POSTGRES_TIMEOUT}
crossdata.catalog.stratio-governance.url = "http://localhost:10000/api/v1"
crossdata.catalog.stratio-governance.url = ${?CROSSDATA_CORE_CATALOG_STRATIO_GOVERNANCE_URL}
crossdata.catalog.stratio-governance.timeout = 10s
crossdata.catalog.stratio-governance.timeout = ${?CROSSDATA_CORE_CATALOG_STRATIO_GOVERNANCE_TIMEOUT}
crossdata.storage.path = "/tmp"
crossdata.storage.path = ${?CROSSDATA_STORAGE_PATH}
crossdata.storage.persistence = "parquet"
crossdata.storage.persistence = ${?CROSSDATA_STORAGE_PERSISTENCE}
crossdata.storage.stratioSecurity = false
crossdata.storage.stratioSecurity = ${?CROSSDATA_STORAGE_STRATIO_SECURITY}
crossdata.storage.stratioSecurityMode = "tls"
crossdata.storage.stratioSecurityMode = ${?CROSSDATA_STORAGE_STRATIO_SECURITY_MODE}
crossdata.security.enable-manager = false
crossdata.security.enable-manager = ${?CROSSDATA_SECURITY_MANAGER_ENABLED}
crossdata.security.manager.class = "com.stratio.gosec.dyplon.plugins.crossdata.GoSecCrossdataSecurityManager"
crossdata.security.manager.class = ${?CROSSDATA_SECURITY_MANAGER_CLASS}
crossdata.session.sparkjars-path = "/opt/sds/sparta/repo"
crossdata.sql.enable-native-queries = false
crossdata.sql.enable-native-queries = ${?CROSSDATA_SQL_NATIVE_QUERIES_ENABLED}
#CROSSDATA_EXTRA_PROPERTIES

# SPARK
spark.master = "local[2]"
spark.master = ${?CROSSDATA_SERVER_CONFIG_SPARK_MASTER}
spark.ui.enabled = ${?CROSSDATA_SERVER_SPARK_UI_ENABLED}
spark.ui.port = 4041
spark.ui.port = ${?CROSSDATA_SERVER_CONFIG_SPARK_UI_PORT}
spark.executor.memory = ${?CROSSDATA_SERVER_CONFIG_SPARK_EXECUTOR_MEMORY}
spark.executor.cores = ${?CROSSDATA_SERVER_CONFIG_SPARK_EXECUTOR_CORES}
spark.driver.memory = ${?CROSSDATA_SERVER_CONFIG_SPARK_DRIVER_MEMORY}
spark.driver.cores = ${?CROSSDATA_SERVER_CONFIG_SPARK_DRIVER_CORES}
spark.cores.max = 1
spark.cores.max = ${?CROSSDATA_SERVER_CONFIG_SPARK_CORES_MAX}
spark.locality.wait = 100
spark.locality.wait = ${?CROSSDATA_SERVER_CONFIG_SPARK_LOCALITY_WAIT}
spark.mesos.coarse = true
spark.sql.caseSensitive = true
spark.sql.caseSensitive = ${?CROSSDATA_SERVER_CONFIG_SPARK_SQL_CASESENSITIVE}
spark.mesos.executor.home = "/opt/spark/dist"
spark.mesos.executor.docker.image = "qa.stratio.com/stratio/spark-stratio-driver:2.2.0-2.4.0"
spark.mesos.executor.docker.image = ${?SPARK_EXECUTOR_BASE_IMAGE}
spark.mesos.executor.docker.volumes = "/opt/mesosphere/packages/:/opt/mesosphere/packages/:ro,/opt/mesosphere/lib/:/opt/mesosphere/lib/:ro,/etc/pki/ca-trust/extracted/java/cacerts/:/usr/lib/jvm/jre1.8.0_112/lib/security/cacerts:ro,/etc/resolv.conf:/etc/resolv.conf:ro"
spark.mesos.executor.docker.volumes = ${?CROSSDATA_SERVER_CONFIG_SPARK_DOCKER_VOLUMES}
spark.hadoop.fs.hdfs.impl.disable.cache = true
spark.hadoop.fs.hdfs.impl.disable.cache = ${?CROSSDATA_HDFS_DELEGATION_TOKEN_DISABLE_CACHE}
spark.mesos.role = ${?SPARK_MESOS_ROLE}
spark.mesos.principal = ${?SPARK_MESOS_PRINCIPAL}
spark.mesos.secret = ${?SPARK_MESOS_SECRET}
spark.mesos.executor.docker.network.name = ${?CALICO_NETWORK}
spark.executorEnv.SPARK_LOG_LEVEL = "ERROR"
spark.executorEnv.SPARK_LOG_LEVEL = ${?SPARK_LOG_LEVEL}
spark.executorEnv.MESOS_NATIVE_JAVA_LIBRARY = "/opt/mesosphere/lib/libmesos.so"
spark.executorEnv.VAULT_HOSTS = ${?VAULT_HOSTS}
spark.executorEnv.VAULT_PROTOCOL = ${?VAULT_PROTOCOL}
spark.executorEnv.VAULT_PORT = ${?VAULT_PORT}
spark.executorEnv.SPARK_DRIVER_SECRET_FOLDER = ${?SPARK_DRIVER_SECRET_FOLDER}
spark.executorEnv.SPARK_SECURITY_DATASTORE_ENABLE = ${?SPARK_SECURITY_DATASTORE_ENABLE}
spark.executorEnv.SPARK_SECURITY_DATASTORE_VAULT_TRUSTSTORE_PATH = ${?SPARK_SECURITY_DATASTORE_VAULT_TRUSTSTORE_PATH}
spark.executorEnv.SPARK_SECURITY_DATASTORE_VAULT_TRUSTSTORE_PASS_PATH = ${?SPARK_SECURITY_DATASTORE_VAULT_TRUSTSTORE_PASS_PATH}
spark.executorEnv.SPARK_SECURITY_DATASTORE_VAULT_CERT_PATH = ${?SPARK_SECURITY_DATASTORE_VAULT_CERT_PATH}
spark.executorEnv.SPARK_SECURITY_DATASTORE_VAULT_CERT_PASS_PATH = ${?SPARK_SECURITY_DATASTORE_VAULT_CERT_PASS_PATH}
spark.executorEnv.SPARK_SECURITY_DATASTORE_VAULT_KEY_PASS_PATH = ${?SPARK_SECURITY_DATASTORE_VAULT_KEY_PASS_PATH}
#Spark s3 props
spark.hadoop.fs.s3a.impl = "com.stratio.spark.fs.s3a.S3AFileSystem" //TODO (Hadoop 2.8+) replace with custom provider "spark.hadoop.fs.s3a.aws.credentials.provider" -> "com.stratio.spark.fs.s3a.auth.VaultAWSCredentialsProvider",
spark.hadoop.fs.s3a.impl = ${?SPARK_HADOOP_FS_S3A_IMPL}
spark.hadoop.fs.s3a.assumedrole.credentials.vault.path = ${?SPARK_HADOOP_FS_S3A_ASSUMEDROLE_CREDENTIALS_VAULT_PATH}
spark.hadoop.fs.s3a.assumedrole.role.arn.vault.path = ${?SPARK_HADOOP_FS_S3A_ASSUMEDROLE_ROLE_ARN_VAULT_PATH}
spark.hadoop.fs.s3a.assumedrole.session.name = ${?SPARK_HADOOP_FS_S3A_ASSUMEDROLE_SESSION_NAME}
spark.hadoop.fs.s3a.assumedrole.session.duration = ${?SPARK_HADOOP_FS_S3A_ASSUMEDROLE_SESSION_DURATION}
spark.hadoop.fs.s3a.assumedrole.sts.region = ${?SPARK_HADOOP_FS_S3A_ASSUMEDROLE_STS_REGION}
spark.hadoop.fs.s3a.assumedrole.sts.endpoint = ${?SPARK_HADOOP_FS_S3A_ASSUMEDROLE_STS_ENDPOINT}
spark.hadoop.fs.s3a.endpoint = ${?SPARK_HADOOP_FS_S3A_ENDPOINT}
spark.hadoop.fs.s3a.connection.maximum = ${?SPARK_HADOOP_FS_S3A_CONNECTION_MAXIMUM}
spark.hadoop.fs.s3a.connection.ssl.enabled = true
spark.hadoop.fs.s3a.connection.ssl.enabled = ${?SPARK_HADOOP_FS_S3A_CONNECTION_SSL_ENABLED}
spark.hadoop.fs.s3a.block.size = ${?SPARK_HADOOP_FS_S3A_BLOCK_SIZE}
spark.hadoop.fs.s3a.sts.proxy.host = ${?SPARK_HADOOP_FS_S3A_STS_PROXY_HOST}
spark.hadoop.fs.s3a.sts.proxy.port = ${?SPARK_HADOOP_FS_S3A_STS_PROXY_PORT}
spark.hadoop.fs.s3a.sts.proxy.ssl.enabled = ${?SPARK_HADOOP_FS_S3A_STS_PROXY_SSL_ENABLED}
spark.hadoop.fs.s3a.sts.proxy.credentials.vault.path = ${?SPARK_HADOOP_FS_S3A_STS_PROXY_CREDENTIALS_VAULT_PATH}

#Spark sftp props
spark.hadoop.fs.sftp.impl = "com.stratio.spark.fs.sftp.SFTPFileSystem" //TODO (Hadoop 2.8+) replace with custom provider "spark.hadoop.fs.sftp.SFTPFileSystem"
spark.hadoop.fs.sftp.impl = ${?SPARK_HADOOP_FS_SFTP_IMPL}
spark.hadoop.fs.sftp.keyfile = ${?SPARTA_PEM_KEY_LOCATION}
spark.hadoop.fs.sftp.connection.max = ${?SPARK_HADOOP_FS_SFTP_CONNECTION_MAX}

#SPARK_EXTRA_PROPERTIES

# Data Governance configuration
governance.http.uri = "https://governance.labs.stratio.com/dictionary"
governance.http.uri= ${?LINEAGE_HTTP_REQUEST_URI}
governance.lineage.http.post.endpoint = "/v1/lineage/actor"
governance.lineage.http.post.endpoint = ${?LINEAGE_POST_PUT_ENDPOINT}
governance.lineage.http.get.endpoint = "/v1/lineage/actor/searchByTransactionId?transactionId="
governance.lineage.http.get.endpoint = ${?LINEAGE_GET_ENDPOINT}
governance.qualityrules.http.get.endpoint = "v1/quality/quality/searchByMetadataPathLike?metadataPathLike="
governance.qualityrules.http.get.endpoint = ${?QUALITY_RULE_GET_ENDPOINT}
governance.qualityrules.http.post.endpoint = "v1/quality/metrics"
governance.qualityrules.http.post.endpoint = ${?QUALITY_RULE_POST_ENDPOINT}

kafka.enable = false
kafka.enable = ${?SPARTA_PLUGIN_KAFKA_ENABLE}

# Kafka for Data Governance and GOSEC
kafka.producer.type = async
kafka.key.serializer = org.apache.kafka.common.serialization.StringSerializer
kafka.value.serializer = org.apache.kafka.common.serialization.StringSerializer
kafka.bootstrap.servers = "localhost:9092"
kafka.bootstrap.servers = ${?SPARTA_PLUGIN_KAFKA_BOOTSTRAP}
kafka.security.protocol = PLAINTEXT
kafka.security.protocol = ${?SPARTA_PLUGIN_KAFKA_SEC_PROTOCOL}
kafka.ssl.truststore.location = ${?SPARTA_TLS_TRUSTSTORE_LOCATION}
kafka.ssl.truststore.password = "123456"
kafka.ssl.truststore.password = ${?SPARTA_TLS_TRUSTSTORE_PASSWORD}
kafka.ssl.keystore.location = ${?SPARTA_TLS_KEYSTORE_LOCATION}
kafka.ssl.keystore.password = "123456"
kafka.ssl.keystore.password = ${?SPARTA_TLS_KEYSTORE_PASSWORD}
kafka.ssl.key.password = "123456"
kafka.ssl.key.password = ${?SPARTA_TLS_KEYSTORE_PASSWORD}
#KAFKA_EXTRA_PROPERTIES

# GOSEC Dyplon Plugin
sparta.security.manager.enabled = false
sparta.security.manager.enabled = ${?SPARTA_SECURITY_MANAGER_ENABLED}
sparta.security.manager.http.enabled = false
sparta.security.manager.http.enabled = ${?SPARTA_SECURITY_MANAGER_HTTP_ENABLED}

kafka.topic = audit
kafka.topic = ${?SPARTA_PLUGIN_KAFKA_TOPIC}
authorizer.default.policy = "Deny"
authorizer.resource.type = "file"
cache.enabled = true
cache.enabled = ${?SPARTA_PLUGIN_CACHE_ENABLED}
cache.ttl = 60000
cache.ttl = ${?SPARTA_PLUGIN_CACHE_TTL}
posix.enable = false
posix.enable = ${?SPARTA_PLUGIN_POSIX_ENABLE}
cache.ldap.size = 50
cache.ldap.size = ${?SPARTA_PLUGIN_LDAP_SIZE}
cache.ldap.interval = 5
cache.ldap.interval = ${?SPARTA_PLUGIN_LDAP_INTERVAL}
cache.ldap.ttl = 30
cache.ldap.ttl = ${?SPARTA_PLUGIN_LDAP_TTL}
local.hostname = ${?GOSEC_LOCAL_HOSTNAME}
java.security.auth.login.config = "/etc/sds/sparta/security/jaas.conf"
java.security.auth.login.config = ${?SPARTA_JAAS_FILE}
tenant.name = ${?SPARTA_TENANT_NAME}

zookeeper.connect = "localhost:2181"
zookeeper.connect = ${?SPARTA_PLUGIN_ZK_CONNECT}
zookeeper.connection.timeout.ms = 6000
zookeeper.session.timeout.ms = 6000
zookeeper.root.path = "/stratio/gosec"
zookeeper.sasl.client = "true"
zookeeper.sasl.client = ${?SPARTA_PLUGIN_CLIENT_ZOOKEEPER_SASL_CLIENT}
zookeeper.watchers.enabled = true
zookeeper.watchers.enabled = ${?SPARTA_PLUGIN_ZOOKEEPER_WATCHERS}
zookeeper.retry.timeout.ms = 6000
zookeeper.retry.timeout.ms = ${?SPARTA_PLUGIN_ZOOKEEPER_RETRY_TIMEOUT_MS}


ldap.host = "localhost"
ldap.host = ${?SPARTA_PLUGIN_LDAP_HOST}
ldap.port = 636
ldap.port = ${?SPARTA_PLUGIN_LDAP_PORT}
ldap.principal = "cn=ldaproot,dc=stratio,dc=com"
ldap.principal = ${?SPARTA_PLUGIN_LDAP_PRINCIPAL}
ldap.authetication = "simple"
ldap.credentials = "stratio"
ldap.credentials = ${?SPARTA_PLUGIN_LDAP_CREDENTIALS}
ldap.userDomain = "ou=People,dc=stratio,dc=com"
ldap.userDomain = ${?SPARTA_PLUGIN_LDAP_USER_DOMAIN}
ldap.groupDomain = "ou=Groups,dc=stratio,dc=com"
ldap.groupDomain = ${?SPARTA_PLUGIN_LDAP_GROUP_DOMAIN}
ldap.secured = true
ldap.secured = ${?SPARTA_PLUGIN_LDAP_SECURED}
ldap.schema = "RFC2307bis"
ldap.schema = ${?SPARTA_PLUGIN_LDAP_SCHEMA}
ldap.pool.maxPoolSize = 10
ldap.pool.maxPoolSize = ${?SPARTA_PLUGIN_LDAP_POOL_MAX_POOL_SIZE}
ldap.pool.minPoolSize = 1
ldap.pool.minPoolSize = ${?SPARTA_PLUGIN_LDAP_POOL_MIN_POOL_SIZE}
ldap.pool.validatePeriodically = "true"
ldap.pool.validatePeriodically = ${?SPARTA_PLUGIN_LDAP_POOL_VALIDATE_PERIODICALLY}
ldap.pool.validatePeriod = 30
ldap.pool.validatePeriod = ${?SPARTA_PLUGIN_LDAP_POOL_VALIDATE_PERIOD}
ldap.pool.validateOnCheckIn = "false"
ldap.pool.validateOnCheckIn = ${?SPARTA_PLUGIN_LDAP_POOL_VALIDATE_ON_CHECK_IN}
ldap.pool.validateOnCheckOut = "true"
ldap.pool.validateOnCheckOut = ${?SPARTA_PLUGIN_LDAP_POOL_VALIDATE_ON_CHECK_OUT}
ldap.mapping.user.id = "uid"
ldap.mapping.user.id = ${?SPARTA_PLUGIN_LDAP_MAPPING_USER_ID}
ldap.mapping.user.name = "cn"
ldap.mapping.user.name = ${?SPARTA_PLUGIN_LDAP_MAPPING_USER_NAME}
ldap.mapping.user.description = "description"
ldap.mapping.user.description = ${?SPARTA_PLUGIN_LDAP_MAPPING_USER_DESCRIPTION}
ldap.mapping.user.mail = "mail"
ldap.mapping.user.mail = ${?SPARTA_PLUGIN_LDAP_MAPPING_USER_MAIL}
ldap.mapping.group.id = "cn"
ldap.mapping.group.id = ${?SPARTA_PLUGIN_LDAP_MAPPING_GROUP_ID}
ldap.mapping.group.name = "description"
ldap.mapping.group.name = ${?SPARTA_PLUGIN_LDAP_MAPPING_GROUP_NAME}
ldap.mapping.group.member = "memberUid"
ldap.mapping.group.member = ${?SPARTA_PLUGIN_LDAP_MAPPING_GROUP_MEMBER}
ldap.mapping.group.description = "description"
ldap.mapping.group.description = ${?SPARTA_PLUGIN_LDAP_MAPPING_GROUP_DESCRIPTION}
ldap.matching.group.linkUser = "uid=%filter"
ldap.matching.group.linkUser = ${?SPARTA_PLUGIN_LDAP_MATCHING_GROUP_LINKUSER}
ldap.queries.user.queryAll = "(&(objectClass=person))"
ldap.queries.user.queryAll = ${?SPARTA_PLUGIN_LDAP_QUERIES_USER_QUERYALL}
ldap.queries.group.queryAll = "(&(objectClass=posixGroup))"
ldap.queries.group.queryAll = ${?SPARTA_PLUGIN_LDAP_QUERIES_GROUP_QUERYALL}
ldap.queries.group.groupByUser = "(&(objectClass=posixGroup)(memberUid=uid=%filter,ou=People,dc=stratio,dc=com))"
ldap.queries.group.groupByUser = ${?SPARTA_PLUGIN_LDAP_QUERIES_GROUP_GROUPBYUSER}
ldap.retry.operations = 5
ldap.retry.operations = ${?SPARTA_PLUGIN_LDAP_RETRY_OPERATIONS}
ldap.retry.waitTimeout = 5
ldap.retry.waitTimeout = ${?SPARTA_PLUGIN_LDAP_RETRY_WAIT_TIMEOUT}
ldap.retry.backoff = 2
ldap.retry.backoff = ${?SPARTA_PLUGIN_LDAP_RETRY_BACKOFF}

audit.stdout.enabled = false
audit.stdout.enabled = ${?SPARTA_PLUGIN_ENABLE_LOG_STDOUT}


#GOSEC Dyplon HTTP
#Crossdata
crossdata.security.plugin.version = 0.15.5-a6e5b87
crossdata.security.plugin.version = ${?GOSEC_CROSSDATA_VERSION}
plugin.clientip = 0.0.0.0
plugin.clientip = ${?SPARTA_PLUGIN_XD_CLIENT_IP}
plugin.name = ${?CROSSDATA_PLUGIN_SERVICE_NAME}
plugin.version = ${pom.version}
plugin.instance = sparta
plugin.instance = ${?SPARTA_PLUGIN_INSTANCE}
plugin.tenant = ${?DYPLON_TENANT_NAME}

#Not used in Sparta
api.endpoint.filter.row = "https://dyplon-http.marathon.mesos:8443/authorize/filter/row/{user}?service={service}&version={version}&instance={instance}&table={value}"
api.endpoint.filter.row = ${?SPARTA_PLUGIN_ENDPOINT_XD_FILTER_ROW}
api.endpoint.filter.columns = "https://dyplon-http.marathon.mesos:8443/authorize/filter/columns/{user}?service={service}&version={version}&instance={instance}&table={value}"
api.endpoint.filter.columns = ${?SPARTA_PLUGIN_ENDPOINT_XD_FILTER_COLUMNS}
#Crossdata

#Api Dyplon Sparta
api.version = ${pom.version}
api.endpoint.tenant.param = ${?DYPLON_SYSTEM_TENANT}
api.service.name =  ${?SPARTA_PLUGIN_SERVICE_NAME}
api.local.hostname = ${?GOSEC_LOCAL_HOSTNAME}
api.dyplon.tenant.name = ${?DYPLON_TENANT_NAME}

#Api dyplon
api.server.cache = true
api.server.cache = ${?SPARTA_PLUGIN_CACHE_ENABLED}
api.endpoint.authorizer = "https://dyplon-http.marathon.mesos:8443/authorize/{user}?service={service}&version={version}&instance={instance}&action={action}&resourceType={resourceType}&value={value}&hierarchy={hierarchy}"
api.endpoint.authorizer = ${?SPARTA_PLUGIN_ENDPOINT_AUTHORIZER}
api.endpoint.register = "https://dyplon-http.marathon.mesos:8443/register"
api.endpoint.register = ${?SPARTA_PLUGIN_ENDPOINT_REGISTER}
api.endpoint.isregistered = "https://dyplon-http.marathon.mesos:8443/register/service/{service}/{version}/{instance}"
api.endpoint.isregistered = ${?SPARTA_PLUGIN_ENDPOINT_IS_REGISTERED}
#Facade security>
api.ssl.encryption = true
api.ssl.encryption = ${?SPARTA_PLUGIN_SSL_ENCRYPTATION}
api.ssl.clientAuth = true
api.ssl.clientAuth = ${?SPARTA_PLUGIN_CLIENT_AUTH}
api.ssl.client.keystore.location = ${?SPARTA_TLS_KEYSTORE_LOCATION}
api.ssl.client.keystore.password =  ${?SPARTA_TLS_KEYSTORE_PASSWORD}
api.ssl.client.keystore.key = ${?SPARTA_TLS_KEYSTORE_PASSWORD}
api.ssl.trustStore.location = ${?SPARTA_TLS_TRUSTSTORE_LOCATION}
api.ssl.trustStore.password = ${?SPARTA_TLS_TRUSTSTORE_PASSWORD}

#Facade cache
facade.auth.cache.enabled = true
facade.auth.cache.enabled = ${?SPARTA_PLUGIN_FACADE_CACHE_ENABLED}
facade.auth.cache.ttl = 60 s
facade.auth.cache.ttl = ${?SPARTA_PLUGIN_FACADE_CACHE_TTL}
facade.auth.cache.size = 100000
facade.auth.cache.size = ${?SPARTA_PLUGIN_FACADE_CACHE_SIZE}
facade.audit.message.asjson = true
facade.audit.message.asjson = ${?SPARTA_PLUGIN_FACADE_AUDIT_ASJSON}

#DYPLON_EXTRA_PROPERTIES
