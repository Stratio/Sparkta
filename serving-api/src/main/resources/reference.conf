# API
sparta.api.host = 0.0.0.0
sparta.api.host = ${?SPARTA_API_HOST}
sparta.api.port = 9090
sparta.api.port = ${?PORT_SPARTAAPI}
sparta.api.certificate-file = "/home/user/certifications/stratio.jks"
sparta.api.certificate-file = ${?SPARTA_API_CERTIFICATE_FILE}
sparta.api.certificate-password = "stratio"
sparta.api.certificate-password = ${?SPARTA_API_CERTIFICATE_PASSWORD}

# SPRAY
spray.can.server.ssl-encryption = "off"
spray.can.server.request-timeout = 20s

# OAUTH2
oauth2.enable = "false"
oauth2.enable = ${?OAUTH2_ENABLE}
oauth2.cookieName = "user"
oauth2.cookieName = ${?OAUTH2_COOKIE_NAME}
oauth2.url.authorize = "https://server.domain:9005/cas/oauth2.0/authorize"
oauth2.url.authorize = ${?OAUTH2_SSL_AUTHORIZE}
oauth2.url.accessToken = "https://server.domain:9005/cas/oauth2.0/accessToken"
oauth2.url.accessToken = ${?OAUTH2_URL_ACCESS_TOKEN}
oauth2.url.profile = "https://server.domain:9005/cas/oauth2.0/profile"
oauth2.url.profile = ${?OAUTH2_URL_PROFILE}
oauth2.url.logout = "https://server.domain:9005/cas/logout"
oauth2.url.logout = ${?OAUTH2_URL_LOGOUT}
oauth2.url.callBack = "http://callback.domain:9090/login"
oauth2.url.callBack = ${?OAUTH2_URL_CALLBACK}
oauth2.url.onLoginGoTo = "/"
oauth2.url.onLoginGoTo = ${?OAUTH2_URL_ON_LOGIN_GO_TO}
oauth2.client.id = "userid"
oauth2.client.id = ${?OAUTH2_CLIENT_ID}
oauth2.client.secret = "usersecret"
oauth2.client.secret = ${?OAUTH2_CLIENT_SECRET}

# ZOOKEEPER
sparta.zookeeper.connectionString = "localhost:2181"
sparta.zookeeper.connectionString = ${?SPARTA_ZOOKEEPER_CONNECTION_STRING}
sparta.zookeeper.storagePath = "/stratio/sparta"
sparta.zookeeper.storagePath = ${?SPARTA_ZOOKEEPER_PATH}
sparta.zookeeper.connectionTimeout = 19000
sparta.zookeeper.connectionTimeout = ${?SPARTA_ZOOKEEPER_CONNECTION_TIMEOUT}
sparta.zookeeper.sessionTimeout = 60000
sparta.zookeeper.sessionTimeout = ${?SPARTA_ZOOKEEPER_SESSION_TIMEOUT}
sparta.zookeeper.retryAttempts = 5
sparta.zookeeper.retryAttempts = ${?SPARTA_ZOOKEEPER_RETRY_ATEMPTS}
sparta.zookeeper.retryInterval = 10000
sparta.zookeeper.retryInterval = ${?SPARTA_ZOOKEEPER_RETRY_INTERVAL}

# AKKA
akka.log-dead-letters = off
akka.loggers = ["akka.event.slf4j.Slf4jLogger"]
akka.logger-startup-timeout = 30s
akka.persistence.journal.plugin = "akka.persistence.journal.leveldb"
akka.persistence.snapshot-store.plugin = "akka.persistence.snapshot-store.local"
akka.persistence.journal.leveldb.dir = "./persistence/journal"
akka.persistence.snapshot-store.local.dir = "./persistence/snapshots"
akka.extensions = ["com.romix.akka.serialization.kryo.KryoSerializationExtension$"]
akka.actor.serializers.kryo = "com.romix.akka.serialization.kryo.KryoSerializer"
akka.actor.serializers.java = "akka.serialization.JavaSerializer"
akka.actor.serialization-bindings {
  "java.io.Serializable" = java
  "com.stratio.sparta.serving.core.actor.SnapshotState" = kryo
}
akka.actor.kryo.type = "nograph"
akka.actor.kryo.idstrategy = "automatic"
akka.actor.kryo.buffer-size = 65536
akka.actor.kryo.kyro-trace = false
akka.actor.kryo.resolve-subclasses = true

# CONFIG
sparta.config.driverLocation = "/opt/sds/sparta/driver/sparta-driver.jar"
sparta.config.driverPackageLocation = "/tmp/sparta/driver"
sparta.config.driverPackageLocation = ${?SPARTA_DRIVER_PACKAGE_LOCATION}
sparta.config.pluginsLocation = "plugins"
sparta.config.pluginsLocation = ${?SPARTA_PLUGIN_PACKAGE_LOCATION}
sparta.config.backupsLocation = "/tmp/sparta/backups"
sparta.config.backupsLocation = ${?SPARTA_BACKUP_LOCATION}
sparta.config.awaitWorkflowChangeStatus = 360s
sparta.config.awaitWorkflowChangeStatus = ${?SPARTA_AWAIT_POLICY_CHANGE_STATUS}
sparta.config.timeout = 20
sparta.config.timeout = ${?SPARTA_TIMEOUT_API_CALLS}
sparta.config.lineage.enable = false
sparta.config.lineage.enable = ${?LINEAGE_ENABLE}
sparta.config.awaitRecovery = 2000
sparta.config.awaitRecovery = ${?SPARTA_AWAIT_RECOVERY}
sparta.config.awaitEnvInit = 1000
sparta.config.awaitEnvInit = ${?SPARTA_AWAIT_ENV_INIT}
sparta.config.serializationTimeout = 5000
sparta.config.serializationTimeout = ${?SPARTA_AWAIT_ENV_TIMEOUT}

# HDFS
# The hadoop user name could be configured by two ways:
# 1. Using the enviroment variable HADOOP_USER_NAME
# 2. Using the variable hadoopUserName from properties file
sparta.hdfs.hadoopUserName = ${?SPARTA_HADOOP_USER_NAME}
# If the variable HADOOP_CONF_DIR is not defined, "hdfsMaster" variable and "hdfsPort" are used to
# connect to HDFS cluster in order to upload jars to HDFS, but the Spark executors and the
# Spark driver need this environment variable defined. In producction environments is recomended use
# HADOOP_CONF_DIR because use HA in Hadoop Namenodes
sparta.hdfs.hdfsMaster = ${?HADOOP_FS_DEFAULT_NAME}
sparta.hdfs.hdfsPort = ${?HADOOP_PORT}
# Configuration to connect to HDFS Kerberized
# The principal name could be configured by two ways:
# 1. Using the enviroment variable SPARTA_PRINCIPAL_NAME
# 2. Using the variable principalName from properties file
# The principal name used to connect to HDFS securized have the order 1, 2
sparta.hdfs.principalName = ${?SPARTA_PRINCIPAL_NAME}
# The keytab path could be configured by two ways:
# 1. Using the enviroment variable SPARTA_KEYTAB_PATH
# 2. Using the variable keytabPath from properties file
sparta.hdfs.keytabPath = ${?SPARTA_KEYTAB_PATH}
sparta.hdfs.reloadKeyTab = ${?HDFS_KEYTAB_RELOAD}
sparta.hdfs.reloadKeyTabTime = ${?HDFS_KEYTAB_RELOAD_TIME}

# MARATHON
sparta.marathon.docker.image = "qa.stratio.com/stratio/sparta:2.0.0-SNAPSHOT"
sparta.marathon.docker.image = ${?SPARTA_DOCKER_IMAGE}
sparta.marathon.docker.forcePullImage = false
sparta.marathon.docker.forcePullImage = ${?SPARTA_MARATHON_FORCE_PULL_IMAGE}
sparta.marathon.docker.privileged = false
sparta.marathon.docker.privileged = ${?SPARTA_MARATHON_PRIVILEGED}
sparta.marathon.docker.includeCommonVolumes = true
sparta.marathon.docker.includeCommonVolumes = ${?SPARTA_MARATHON_INCLUDE_COMMON_VOLUMES}
sparta.marathon.jar = "/opt/sds/sparta/driver/sparta-driver.jar"
sparta.marathon.jar = ${?SPARTA_MARATHON_JAR}
sparta.marathon.template.file = "/etc/sds/sparta/marathon-app-template.json"
sparta.marathon.template.file = ${?SPARTA_MARATHON_TEMPLATE_FILE}
sparta.marathon.mesosphere.lib = "/opt/mesosphere/lib"
sparta.marathon.mesosphere.lib = ${?SPARTA_MARATHON_MESOSPHERE_LIB}
sparta.marathon.mesosphere.packages = "/opt/mesosphere/packages"
sparta.marathon.mesosphere.packages = ${?SPARTA_MARATHON_MESOSPHERE_PACKAGES}
sparta.marathon.gracePeriodSeconds = 240
sparta.marathon.gracePeriodSeconds = ${?SPARTA_MARATHON_GRACEPERIODS_SECONDS}
sparta.marathon.intervalSeconds = 60
sparta.marathon.intervalSeconds = ${?SPARTA_MARATHON_INTERVAL_SECONDS}
sparta.marathon.timeoutSeconds = 20
sparta.marathon.timeoutSeconds = ${?SPARTA_MARATHON_TIMEOUT_SECONDS}
sparta.marathon.maxConsecutiveFailures = 3
sparta.marathon.maxConsecutiveFailures = ${?SPARTA_MARATHON_MAX_FAILURES}
sparta.marathon.sso.uri = ${?MARATHON_SSO_URI}
sparta.marathon.sso.username = ${?MARATHON_SSO_USERNAME}
sparta.marathon.sso.password = ${?MARATHON_SSO_PASSWORD}
sparta.marathon.sso.clientId = ${?MARATHON_SSO_CLIENT_ID}
sparta.marathon.sso.redirectUri = ${?MARATHON_SSO_REDIRECT_URI}
sparta.marathon.sso.retries = ${?MARATHON_SSO_RETRIES}
sparta.marathon.tikitakka.marathon.uri = ${?MARATHON_TIKI_TAKKA_MARATHON_URI}
sparta.marathon.tikitakka.marathon.api.version = "v2"
sparta.marathon.tikitakka.marathon.api.version = ${?MARATHON_TIKI_TAKKA_MARATHON_API_VERSION}


# CROSSDATA
crossdata.catalog.class = ${?CROSSDATA_CORE_CATALOG_CLASS}
crossdata.catalog.zookeeper.connectionString = "localhost:2181"
crossdata.catalog.zookeeper.connectionString = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_CONNECTIONSTRING}
crossdata.catalog.zookeeper.connectionTimeout = 15s
crossdata.catalog.zookeeper.connectionTimeout = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_CONNECTIONTIMEOUT}
crossdata.catalog.zookeeper.sessionTimeout = 60s
crossdata.catalog.zookeeper.sessionTimeout = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_SESSIONTIMEOUT}
crossdata.catalog.zookeeper.retryAttempts = 5
crossdata.catalog.zookeeper.retryAttempts = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_RETRYATTEMPTS}
crossdata.catalog.zookeeper.retryInterval = 10s
crossdata.catalog.zookeeper.retryInterval = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_RETRYINTERVAL}
crossdata.catalog.zookeeper.prefix = "crossdataCluster"
crossdata.catalog.zookeeper.prefix = ${?CROSSDATA_CORE_CATALOG_PREFIX}
crossdata.storage.path = "/tmp"
crossdata.storage.path = ${?CROSSDATA_STORAGE_PATH}
crossdata.storage.persistence = "parquet"
crossdata.storage.persistence = ${?CROSSDATA_STORAGE_PERSISTENCE}
crossdata.storage.stratioSecurity = false
crossdata.storage.stratioSecurity = ${?CROSSDATA_STORAGE_STRATIO_SECURITY}
crossdata.storage.stratioSecurityMode = "tls"
crossdata.storage.stratioSecurityMode = ${?CROSSDATA_STORAGE_STRATIO_SECURITY_MODE}
crossdata.security.enable-manager = false
crossdata.security.enable-manager = ${?CROSSDATA_SECURITY_MANAGER_ENABLED}
crossdata.security.manager.class = "com.stratio.gosec.dyplon.plugins.crossdata.GoSecCrossdataSecurityManager"
crossdata.security.manager.class = ${?CROSSDATA_SECURITY_MANAGER_CLASS}
crossdata.session.sparkjars-path = "/opt/sds/sparta/repo"

# SPARK
spark.master = "local[*]"
spark.master = ${?CROSSDATA_SERVER_CONFIG_SPARK_MASTER}
spark.ui.enabled = ${?CROSSDATA_SERVER_SPARK_UI_ENABLED}
spark.ui.port = 4041
spark.ui.port = ${?CROSSDATA_SERVER_CONFIG_SPARK_UI_PORT}
spark.executor.memory = ${?CROSSDATA_SERVER_CONFIG_SPARK_EXECUTOR_MEMORY}
spark.executor.cores = ${?CROSSDATA_SERVER_CONFIG_SPARK_EXECUTOR_CORES}
spark.driver.memory = ${?CROSSDATA_SERVER_CONFIG_SPARK_DRIVER_MEMORY}
spark.driver.cores = ${?CROSSDATA_SERVER_CONFIG_SPARK_DRIVER_CORES}
spark.cores.max = 1
spark.cores.max = ${?CROSSDATA_SERVER_CONFIG_SPARK_CORES_MAX}
spark.locality.wait = 100
spark.locality.wait = ${?CROSSDATA_SERVER_CONFIG_SPARK_LOCALITY_WAIT}
spark.mesos.coarse = true
spark.sql.caseSensitive = true
spark.sql.caseSensitive = ${?CROSSDATA_SERVER_CONFIG_SPARK_SQL_CASESENSITIVE}
spark.mesos.executor.home = "/opt/spark/dist"
spark.mesos.executor.docker.image = "qa.stratio.com/stratio/stratio-spark:2.2.0.5"
spark.mesos.executor.docker.image = ${?CROSSDATA_SERVER_CONFIG_SPARK_DOCKER_IMAGE}
spark.mesos.executor.docker.volumes = "/opt/mesosphere/packages/:/opt/mesosphere/packages/:ro,/opt/mesosphere/lib/:/opt/mesosphere/lib/:ro,/etc/pki/ca-trust/extracted/java/cacerts/:/usr/lib/jvm/jre1.8.0_112/lib/security/cacerts:ro,/etc/resolv.conf:/etc/resolv.conf:ro"
spark.mesos.executor.docker.volumes = ${?CROSSDATA_SERVER_CONFIG_SPARK_DOCKER_VOLUMES}
spark.hadoop.fs.hdfs.impl.disable.cache = true
spark.hadoop.fs.hdfs.impl.disable.cache = ${?CROSSDATA_HDFS_DELEGATION_TOKEN_DISABLE_CACHE}
spark.mesos.role = ${?SPARK_MESOS_ROLE}
spark.mesos.principal = ${?SPARK_MESOS_PRINCIPAL}
spark.mesos.secret = ${?SPARK_MESOS_SECRET}
spark.mesos.executor.docker.network.name = ${?CALICO_NETWORK}
spark.executorEnv.SPARK_LOG_LEVEL = "ERROR"
spark.executorEnv.SPARK_LOG_LEVEL = ${?SPARK_LOG_LEVEL}
spark.executorEnv.MESOS_NATIVE_JAVA_LIBRARY = "/opt/mesosphere/lib/libmesos.so"
spark.executorEnv.VAULT_HOSTS = ${?VAULT_HOSTS}
spark.executorEnv.VAULT_PROTOCOL = ${?VAULT_PROTOCOL}
spark.executorEnv.VAULT_PORT = ${?VAULT_PORT}
spark.executorEnv.SPARK_DRIVER_SECRET_FOLDER = ${?SPARK_DRIVER_SECRET_FOLDER}
spark.executorEnv.SPARK_SECURITY_DATASTORE_ENABLE = ${?SPARK_SECURITY_DATASTORE_ENABLE}
spark.executorEnv.SPARK_SECURITY_DATASTORE_VAULT_TRUSTSTORE_PATH = ${?SPARK_SECURITY_DATASTORE_VAULT_TRUSTSTORE_PATH}
spark.executorEnv.SPARK_SECURITY_DATASTORE_VAULT_TRUSTSTORE_PASS_PATH = ${?SPARK_SECURITY_DATASTORE_VAULT_TRUSTSTORE_PASS_PATH}
spark.executorEnv.SPARK_SECURITY_DATASTORE_VAULT_CERT_PATH = ${?SPARK_SECURITY_DATASTORE_VAULT_CERT_PATH}
spark.executorEnv.SPARK_SECURITY_DATASTORE_VAULT_CERT_PASS_PATH = ${?SPARK_SECURITY_DATASTORE_VAULT_CERT_PASS_PATH}
spark.executorEnv.SPARK_SECURITY_DATASTORE_VAULT_KEY_PASS_PATH = ${?SPARK_SECURITY_DATASTORE_VAULT_KEY_PASS_PATH}

# Data Governance configuration
sender.sink = "KAFKA_PLAIN"
sender.sink = ${?DG_SINK}
sender.topic = "dg-metadata"
sender.topic = ${?DG_KAFKA_TOPIC}

# Kafka for Data Governance and GOSEC
kafka.producer.type = async
kafka.key.serializer = org.apache.kafka.common.serialization.StringSerializer
kafka.value.serializer = org.apache.kafka.common.serialization.StringSerializer
kafka.bootstrap.servers = "localhost:9092"
kafka.bootstrap.servers = ${?SPARTA_PLUGIN_KAFKA_BOOTSTRAP}
kafka.security.protocol = PLAINTEXT
kafka.security.protocol = ${?SPARTA_PLUGIN_KAFKA_SEC_PROTOCOL}
kafka.ssl.truststore.location = ${?SPARTA_TRUST_JKS_NAME}
kafka.ssl.truststore.password = "123456"
kafka.ssl.truststore.password = ${?SPARTA_TRUSTSTORE_PASSWORD}
kafka.ssl.keystore.location = ${?SPARTA_TLS_JKS_NAME}
kafka.ssl.keystore.password = "123456"
kafka.ssl.keystore.password = ${?SPARTA_API_CERTIFICATE_PASSWORD}
kafka.ssl.key.password = "123456"
kafka.ssl.key.password = ${?SPARTA_API_CERTIFICATE_PASSWORD}

# GOSEC Dyplon Plugin
sparta.security.manager.enabled = false
sparta.security.manager.enabled = ${?SPARTA_SECURITY_MANAGER_ENABLED}

plugin.instance = sparta
plugin.instance = ${?SPARTA_PLUGIN_INSTANCE}
kafka.topic = audit
kafka.topic = ${?SPARTA_PLUGIN_KAFKA_TOPIC}
authorizer.default.policy = "Deny"
authorizer.resource.type = "file"
cache.enabled = false
cache.enabled = ${?SPARTA_PLUGIN_CACHE_ENABLED}
cache.ttl = 60000
cache.ttl = ${?SPARTA_PLUGIN_CACHE_TTL}
local.hostname = ${?GOSEC_LOCAL_HOSTNAME}
java.security.auth.login.config = "/etc/sds/sparta/security/jaas.conf"
java.security.auth.login.config = ${?SPARTA_JAAS_FILE}

zookeeper.connect = "localhost:2181"
zookeeper.connect = ${?SPARTA_PLUGIN_ZK_CONNECT}
zookeeper.connection.timeout.ms = 6000
zookeeper.session.timeout.ms = 6000
zookeeper.root.path = "/stratio/gosec"
zookeeper.sasl.client = "true"
zookeeper.sasl.client = ${?SPARTA_PLUGIN_CLIENT_ZOOKEEPER_SASL_CLIENT}
zookeeper.watchers.enabled = true
zookeeper.watchers.enabled = ${?SPARTA_PLUGIN_ZOOKEEPER_WATCHERS}

ldap.host = "localhost"
ldap.host = ${?SPARTA_PLUGIN_LDAP_HOST}
ldap.port = 636
ldap.port = ${?SPARTA_PLUGIN_LDAP_PORT}
ldap.principal = "cn=ldaproot,dc=stratio,dc=com"
ldap.principal = ${?SPARTA_PLUGIN_LDAP_PRINCIPAL}
ldap.authetication = "simple"
ldap.credentials = "stratio"
ldap.credentials = ${?SPARTA_PLUGIN_LDAP_CREDENTIALS}
ldap.userDomain = "ou=People,dc=stratio,dc=com"
ldap.userDomain = ${?SPARTA_PLUGIN_LDAP_USER_DOMAIN}
ldap.groupDomain = "ou=Groups,dc=stratio,dc=com"
ldap.groupDomain = ${?SPARTA_PLUGIN_LDAP_GROUP_DOMAIN}
ldap.secured = true
ldap.secured = ${?SPARTA_PLUGIN_LDAP_SECURED}
ldap.schema = "RFC2307bis"
ldap.schema = ${?SPARTA_PLUGIN_LDAP_SCHEMA}
ldap.pool.maxPoolSize = 10
ldap.pool.maxPoolSize = ${?SPARTA_PLUGIN_LDAP_POOL_MAX_POOL_SIZE}
ldap.pool.minPoolSize = 1
ldap.pool.minPoolSize = ${?SPARTA_PLUGIN_LDAP_POOL_MIN_POOL_SIZE}
ldap.pool.validatePeriodically = "true"
ldap.pool.validatePeriodically = ${?SPARTA_PLUGIN_LDAP_POOL_VALIDATE_PERIODICALLY}
ldap.pool.validatePeriod = 30
ldap.pool.validatePeriod = ${?SPARTA_PLUGIN_LDAP_POOL_VALIDATE_PERIOD}
ldap.pool.validateOnCheckIn = "false"
ldap.pool.validateOnCheckIn = ${?SPARTA_PLUGIN_LDAP_POOL_VALIDATE_ON_CHECK_IN}
ldap.pool.validateOnCheckOut = "true"
ldap.pool.validateOnCheckOut = ${?SPARTA_PLUGIN_LDAP_POOL_VALIDATE_ON_CHECK_OUT}
ldap.mapping.user.id = "uid"
ldap.mapping.user.id = ${?SPARTA_PLUGIN_LDAP_MAPPING_USER_ID}
ldap.mapping.user.name = "cn"
ldap.mapping.user.name = ${?SPARTA_PLUGIN_LDAP_MAPPING_USER_NAME}
ldap.mapping.user.description = "description"
ldap.mapping.user.description = ${?SPARTA_PLUGIN_LDAP_MAPPING_USER_DESCRIPTION}
ldap.mapping.user.mail = "mail"
ldap.mapping.user.mail = ${?SPARTA_PLUGIN_LDAP_MAPPING_USER_MAIL}
ldap.mapping.group.id = "cn"
ldap.mapping.group.id = ${?SPARTA_PLUGIN_LDAP_MAPPING_GROUP_ID}
ldap.mapping.group.name = "description"
ldap.mapping.group.name = ${?SPARTA_PLUGIN_LDAP_MAPPING_GROUP_NAME}
ldap.mapping.group.member = "memberUid"
ldap.mapping.group.member = ${?SPARTA_PLUGIN_LDAP_MAPPING_GROUP_MEMBER}
ldap.mapping.group.description = "description"
ldap.mapping.group.description = ${?SPARTA_PLUGIN_LDAP_MAPPING_GROUP_DESCRIPTION}
ldap.matching.group.linkUser = "uid=%filter"
ldap.matching.group.linkUser = ${?SPARTA_PLUGIN_LDAP_MATCHING_GROUP_LINKUSER}
ldap.queries.user.queryAll = "(&(objectClass=person))"
ldap.queries.user.queryAll = ${?SPARTA_PLUGIN_LDAP_QUERIES_USER_QUERYALL}
ldap.queries.group.queryAll = "(&(objectClass=posixGroup))"
ldap.queries.group.queryAll = ${?SPARTA_PLUGIN_LDAP_QUERIES_GROUP_QUERYALL}
ldap.queries.group.groupByUser = "(&(objectClass=posixGroup)(memberUid=uid=%filter,ou=People,dc=stratio,dc=com))"
ldap.queries.group.groupByUser =  ${?SPARTA_PLUGIN_LDAP_QUERIES_GROUP_GROUPBYUSER}