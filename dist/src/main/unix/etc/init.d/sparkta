#!/bin/bash
### BEGIN INIT INFO
# Provides:          sparkta
# Required-Start:    $remote_fs $network
# Required-Stop:     $remote_fs $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Available actions on sparkta: start/status/stop and restart
# Description:       Enable sparkta as service.
### END INIT INFO
#
# NAME – name of the application, must be the same as the name of shell script
# generated by Play framework to run the app
# APP_DIR – path to directory where you have unzipped the packaged app
#
#
# Usage: control.sh {start|stop|status|restart}
#
#
# The script uses sparkta.pid file generated by Play framework which contains ID of the
# application server process.
#
#
# START YOUR APPLICATION WHEN MACHINE STARTS
# ==========================================
#
# The script uses sparkta.pid file generated by Play framework which contains ID of
# the application server process.
#
#
# SAFE START
# ==========
#
# After starting the application the script checks whether the RUNNING_PID file has
# been created and whether the process is really running.
#
#
# SAFE STOP
# =========
#
# Stop checks whether the process whose ID is in the RUNNING_PID file really belongs
# to your application. This is an important check so that we don’t kill an innocent
# process by accident. Then it sends termination signals to the process starting
# with the most gentle ones until the process dies.
#
#

source /etc/default/sparkta

# Script arguments (start, stop, restart or status)
COMMAND=$1

# ***********************************************
# ************* Set these variables ***********

NAME=run
APP_DIR=/opt/sds/sparkta
PID_DIR=/var/run/sds
USER=stratio
GROUP=stratio

export SPARKTA_HOME=$APP_DIR

# Path to the RUNNING_PID file containing process ID
PID_FILE=$PID_DIR/sparkta.pid

# Helper functions
echoProgress() {
	setColor 6
	printf "%-70s" "$1..."
	resetColor
	return 0
}

echoError() {
	setColor 6
	printf "ERROR"
	if [ ! -z "$1" ]
	then
		resetColor
		printf " [$1]"
	fi
	printf "\n"
	resetColor
	return 0
}

echoOK() {
	setColor 2
	printf "OK"
	if [ ! -z "$1" ]
	then
		resetColor
		printf " [$1]"
	fi
	printf "\n"
	resetColor
	return 0
}

checkResult() {
	if [ "$1" -ne 0 ]
	then
	echoError "$2"
	exit 1
	fi
}

setColor() {
	tput setaf $1 2>/dev/null
}

resetColor() {
	tput sgr0 2>/dev/null
}

# Checks if RUNNING_PID file exists and whether the process is really running.
checkPidFile() {
	if [ -s $PID_FILE ]
	then
		if ps -p `cat $PID_FILE` > /dev/null
		then
			# The file exists and the process is running
			return 1
		else
			# The file exists, but the process is dead
			return 2
		fi
	fi

	# The file doesn't exist
	return 0
}

# Gently kill the given process
kill_softly() {
	SAFE_CHECK=`ps -ef | grep $@ | grep $APP_DIR`
	if [ -z "$SAFE_CHECK" ]
	then
		# Process ID doesn't belong to expected application! Don't kill it!
		return 1
	else
		# Send termination signals one by one
		for sig in TERM KILL; do
			if kill -$sig "$@" > /dev/null 2>&1 ;	then
				while kill -0 "$@" > /dev/null 2>&1; do
					sleep 0.5
				done
			fi
			sleep 2
		done
	fi
}

# Get process ID from RUNNING_PID file and print it
printPid() {
	PID=`cat $PID_FILE`
	printf "PID=$PID"
}

# Check input arguments
checkArgs() {
	# Check command
	case "$COMMAND" in
		start | stop | restart | status) ;;
		*)
			echoError "Unknown command"
			return 1
		;;
	esac

	# Check application name
	if [ -z "$NAME" ]
	then
		echoError "Application name not set!"
		return 1
	fi

	# Check application directory
	if [ -z "$APP_DIR" ]
	then
		echoError "Application installation directory not set!"
		return 1
	fi
}

checkAppStarted() {
	# Wait a bit
	sleep 3

	# Check if RUNNING_PID file exists and if process is really running
	checkPidFile
	if [ $? != 1 ]
	then
		echoError
		cat $TMP_LOG 1>&2
		exit 1
	fi
}

checkPidFolder() {
	# Create Run directory
  if [ ! -d "$PID_DIR" ]; then
    mkdir -p "$PID_DIR"
    chown "$USER":"$GROUP" $PID_DIR
    chmod 775 $PID_DIR
    if [ $? -ne 0 ]; then exit 1; fi
  fi
}

createPidFile() {
	checkPidFolder
  /bin/touch $PID_FILE
	/bin/chmod 777 $PID_FILE
}

# Check input arguments
checkArgs
if [ $? != 0 ]
then
	echo "Usage: $0 {start|stop|status|restart}"
	exit 1
fi

case "${COMMAND}" in
	start)
		echoProgress "Starting $NAME"

		checkPidFile
		case $? in
			1) echoOK "$(printPid) already started"
				exit ;;
			2) # Delete the RUNNING_PID FILE
			rm $PID_FILE
			createPidFile
			;;
		esac

		SCRIPT_TO_RUN=bin/$NAME
		SCRIPT_PATH=$APP_DIR/$SCRIPT_TO_RUN
		if [ ! -f $SCRIPT_PATH ]
		then
			echoError "Play script doesn't exist!"
			exit 1
		fi

		# * * * Run the Play application * * *
		cd $APP_DIR
		PID=`sh $SCRIPT_TO_RUN  > /dev/null 2>&1 & echo $!`

		# Check if successfully started
		if [ $? != 0 ]
		then
			echoError
			exit 1
		else
			#checkAppStarted
			echoOK "PID=$PID"
			#save PID
			echoProgress "Saving PID $PID in $PID_FILE"
			createPidFile
			echo $PID > $PID_FILE
		fi
	;;
	status)
		echoProgress "Checking $NAME"
		checkPidFile
		case $? in
			0) echoOK "not running"
			 exit 3;;
			1) echoOK "$(printPid) running"
			 exit 0;;
			2) echoError "process dead but RUNNING_PID file exists"
			 rm $PID_FILE
			 exit 1;;
		esac
	;;
	stop)
		echoProgress "Stopping $NAME"
		checkPidFile
		case $? in
			0) echoOK "wasn't running" ;;
			1) PRINTED_PID=$(printPid)
				kill_softly `cat $PID_FILE`
				if [ $? != 0 ]
				then
					echoError "$PRINTED_PID doesn't belong to $NAME! Human intervention is required."
					exit 1
				else
					echoOK "$PRINTED_PID stopped"
					echoProgress "Removing $PID_FILE"
					rm $PID_FILE
					createPidFile
				fi ;;
			2) echoError "RUNNING_PID exists but process is already dead" ;;
		esac
	;;

	restart)
		$0 stop $NAME
		if [ $? == 0 ]
		then
			$0 start $NAME
			if [ $? == 0 ]
			then
				# Success
				exit
			fi
		fi
		exit 1
	;;
esac
