# SECURITY

sparta.ssl.truststore.location = ${?SPARTA_TLS_TRUSTSTORE_LOCATION}
sparta.ssl.truststore.password = ${?SPARTA_TLS_TRUSTSTORE_PASSWORD}
sparta.ssl.keystore.location = ${?SPARTA_TLS_KEYSTORE_LOCATION}
sparta.ssl.keystore.password = ${?SPARTA_TLS_KEYSTORE_PASSWORD}


# ZOOKEEPER
sparta.zookeeper.connectionString = "localhost:2181"
sparta.zookeeper.connectionString = ${?SPARTA_ZOOKEEPER_CONNECTION_STRING}
sparta.zookeeper.storagePath = "/stratio/sparta/sparta"
sparta.zookeeper.storagePath = ${?SPARTA_ZOOKEEPER_PATH}
sparta.zookeeper.connectionTimeout = 19000
sparta.zookeeper.connectionTimeout = ${?SPARTA_ZOOKEEPER_CONNECTION_TIMEOUT}
sparta.zookeeper.sessionTimeout = 60000
sparta.zookeeper.sessionTimeout = ${?SPARTA_ZOOKEEPER_SESSION_TIMEOUT}
sparta.zookeeper.retryAttempts = 5
sparta.zookeeper.retryAttempts = ${?SPARTA_ZOOKEEPER_RETRY_ATEMPTS}
sparta.zookeeper.retryInterval = 10000
sparta.zookeeper.retryInterval = ${?SPARTA_ZOOKEEPER_RETRY_INTERVAL}

# POSTGRES
sparta.postgres.host="jdbc:postgresql://localhost:5432"
sparta.postgres.host=${?SPARTA_POSTGRES_HOST}
sparta.postgres.database="postgres"
sparta.postgres.database=${?SPARTA_POSTGRES_DATABASE}
sparta.postgres.extraParams=""
sparta.postgres.extraParams=${?SPARTA_POSTGRES_EXTRAPARAMS}
sparta.postgres.schemaName="sparta"
sparta.postgres.schemaName=${?SPARTA_POSTGRES_SCHEMA_NAME}
sparta.postgres.user="postgres"
sparta.postgres.user=${?SPARTA_POSTGRES_USER}
sparta.postgres.driver = org.postgresql.Driver
sparta.postgres.connectionPool = "HikariCP"
sparta.postgres.initializationFailFast = true
sparta.postgres.poolName =  "spartaPostgresPool"
sparta.postgres.keepAliveConnection = true
sparta.postgres.keepAliveConnection = ${?SPARTA_POSTGRES_KEEP_ALIVE}
sparta.postgres.numThreads = 5
sparta.postgres.numThreads = ${?SPARTA_POSTGRES_POOL_SIZE}
sparta.postgres.sslenabled = false
sparta.postgres.sslenabled = ${?SECURITY_TLS_ENABLE}
sparta.postgres.sslcert = ${?SPARTA_TLS_CERT}
sparta.postgres.sslkey = ${?SPARTA_TLS_KEY_PKCS8}
sparta.postgres.sslrootcert = ${?SPARTA_TLS_ROOTCERT}

#Ignite
sparta.ignite.enabled = false
sparta.ignite.security.enabled = false
sparta.ignite.security.enabled = ${?SECURITY_TLS_ENABLE}
sparta.ignite.instance.name = "sparta-ignite-instance"
sparta.ignite.instance.name = ${?SPARTA_IGNITE_INSTANCE_NAME}
sparta.ignite.cache.name = "sparta-cache"
sparta.ignite.cache.name = ${?SPARTA_IGNITE_CACHE_NAME}
sparta.ignite.cluster.enabled = true
sparta.ignite.cluster.enabled = ${?SPARTA_IGNITE_CLUSTER_ENABLED}
sparta.ignite.memory.initialSizeMB = 128
sparta.ignite.memory.initialSizeMB = ${?SPARTA_IGNITE_MEM_INITIAL_SIZE}
sparta.ignite.memory.maxSizeMB = 256
sparta.ignite.memory.maxSizeMB = ${?SPARTA_IGNITE_MEM_MAX_SIZE}
sparta.ignite.communication.spiPort = 11000
sparta.ignite.communication.spiPort = ${?PORT_SPIIGNITE}
sparta.ignite.communication.spiPortRange = 0
sparta.ignite.communication.spiPortRange = ${?SPARTA_IGNITE_SPI_PORT_RANGE}
sparta.ignite.persistence.enabled = false
sparta.ignite.persistence.enabled = ${?SPARTA_IGNITE_PERSISTENCE_ENABLED}
sparta.ignite.persistence.walPath = "/tmp/ignite/wal"
sparta.ignite.persistence.walPath = ${?SPARTA_IGNITE_PERSISTENCE_WAL}
sparta.ignite.persistence.persistencePath = "/tmp/ignite/persistence"
sparta.ignite.persistence.persistencePath = ${?SPARTA_IGNITE_PERSISTENCE_PATH}

#CONFIG
sparta.config.crossdata.reference = "/etc/sds/sparta/reference.conf"
sparta.config.timeout = 20
sparta.config.timeout = ${?SPARTA_TIMEOUT_API_CALLS}

# INTELLIGENCE
sparta.intelligence.repository.url = "http://localhost:8000"
sparta.intelligence.repository.url = ${?INTELLIGENCE_URL}

# HDFS
# The hadoop user name could be configured by two ways:
# 1. Using the enviroment variable HADOOP_USER_NAME
# 2. Using the variable hadoopUserName from properties file
sparta.hdfs.hadoopUserName = ${?SPARTA_HADOOP_USER_NAME}
# If the variable HADOOP_CONF_DIR is not defined, "hdfsMaster" variable and "hdfsPort" are used to
# connect to HDFS cluster in order to upload jars to HDFS, but the Spark executors and the
# Spark driver need this environment variable defined. In producction environments is recomended use
# HADOOP_CONF_DIR because use HA in Hadoop Namenodes
sparta.hdfs.hdfsMaster = ${?HADOOP_FS_DEFAULT_NAME}
sparta.hdfs.hdfsPort = ${?HADOOP_PORT}
# Configuration to connect to HDFS Kerberized
# The principal name could be configured by two ways:
# 1. Using the enviroment variable SPARTA_PRINCIPAL_NAME
# 2. Using the variable principalName from properties file
# The principal name used to connect to HDFS securized have the order 1, 2
sparta.hdfs.principalName = ${?SPARTA_PRINCIPAL_NAME}
# The keytab path could be configured by two ways:
# 1. Using the enviroment variable SPARTA_KEYTAB_PATH
# 2. Using the variable keytabPath from properties file
sparta.hdfs.keytabPath = ${?SPARTA_KEYTAB_PATH}
sparta.hdfs.reloadKeyTab = ${?HDFS_KEYTAB_RELOAD}
sparta.hdfs.reloadKeyTabTime = ${?HDFS_KEYTAB_RELOAD_TIME}

# AKKA
akka.log-dead-letters = off
akka.loggers = ["akka.event.slf4j.Slf4jLogger"]
akka.logger-startup-timeout = 30s
akka.persistence.journal.plugin = "akka.persistence.journal.leveldb"
akka.persistence.snapshot-store.plugin = "akka.persistence.snapshot-store.local"
akka.persistence.journal.leveldb.dir = "/var/sds/sparta/spark-driver/persistence/journal"
akka.persistence.snapshot-store.local.dir = "/var/sds/sparta/spark-driver/persistence/snapshots"
akka.extensions = ["com.romix.akka.serialization.kryo.KryoSerializationExtension$"]
akka.actor.serializers.kryo = "com.romix.akka.serialization.kryo.KryoSerializer"
akka.actor.serializers.java = "akka.serialization.JavaSerializer"
akka.actor.serialization-bindings {
  "java.io.Serializable" = java
}
akka.actor.kryo.type = "nograph"
akka.actor.kryo.idstrategy = "automatic"
akka.actor.kryo.buffer-size = 65536
akka.actor.kryo.kyro-trace = false
akka.actor.kryo.resolve-subclasses = true


# CROSSDATA catalog configuration
crossdata.catalog.class = ${?CROSSDATA_CORE_CATALOG_CLASS}
crossdata.catalog.prefix = "crossdataCluster"
crossdata.catalog.prefix = ${?CROSSDATA_CORE_CATALOG_PREFIX}
crossdata.catalog.cache-ttl = 60
crossdata.catalog.cache-ttl = ${?CROSSDATA_CORE_CATATALOG_CACHETTL}
crossdata.catalog.cache-enabled = false
crossdata.catalog.cache-enabled = ${?CROSSDATA_CORE_CATALOG_CACHE}
crossdata.catalog.zookeeper.connectionString = "localhost:2181"
crossdata.catalog.zookeeper.connectionString = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_CONNECTIONSTRING}
crossdata.catalog.zookeeper.connectionTimeout = 15s
crossdata.catalog.zookeeper.connectionTimeout = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_CONNECTIONTIMEOUT}
crossdata.catalog.zookeeper.sessionTimeout = 60s
crossdata.catalog.zookeeper.sessionTimeout = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_SESSIONTIMEOUT}
crossdata.catalog.zookeeper.retryAttempts = 5
crossdata.catalog.zookeeper.retryAttempts = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_RETRYATTEMPTS}
crossdata.catalog.zookeeper.retryInterval = 10s
crossdata.catalog.zookeeper.retryInterval = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_RETRYINTERVAL}
crossdata.catalog.zookeeper.compatibilityWithStratioSecurityMode = false
crossdata.catalog.zookeeper.compatibilityWithStratioSecurityMode = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_COMPATIBILITY_WITH_SECURITY_MODE}
crossdata.catalog.zookeeper.cache = false
crossdata.catalog.zookeeper.cache = ${?CROSSDATA_CORE_CATALOG_ZOOKEEPER_CACHE}
crossdata.catalog.postgres.url = "jdbc:postgresql://localhost:5432"
crossdata.catalog.postgres.url = ${?CROSSDATA_CORE_CATALOG_POSTGRES_URL}
crossdata.catalog.postgres.user = "postgres"
crossdata.catalog.postgres.user = ${?CROSSDATA_CORE_CATALOG_POSTGRES_USER}
crossdata.catalog.postgres.password = ${?CROSSDATA_CORE_CATALOG_POSTGRES_PWD}
crossdata.catalog.postgres.stratioSecurity = false
crossdata.catalog.postgres.stratioSecurity = ${?CROSSDATA_CORE_CATALOG_POSTGRES_STRATIOSECURITY}
crossdata.catalog.postgres.stratioSecurityMode = "tls"
crossdata.catalog.postgres.stratioSecurityMode = ${?CROSSDATA_CORE_CATALOG_POSTGRES_STRATIOSECURITYMODE}
crossdata.catalog.postgres.timeout = 10s
crossdata.catalog.postgres.timeout = ${?CROSSDATA_CORE_CATALOG_POSTGRES_TIMEOUT}
crossdata.catalog.stratio-governance.url = "http://localhost:10000/api/v1"
crossdata.catalog.stratio-governance.url = ${?CROSSDATA_CORE_CATALOG_STRATIO_GOVERNANCE_URL}
crossdata.catalog.stratio-governance.timeout = 10s
crossdata.catalog.stratio-governance.timeout = ${?CROSSDATA_CORE_CATALOG_STRATIO_GOVERNANCE_TIMEOUT}
crossdata.storage.path = "/tmp"
crossdata.storage.path = ${?CROSSDATA_STORAGE_PATH}
crossdata.storage.persistence = "parquet"
crossdata.storage.persistence = ${?CROSSDATA_STORAGE_PERSISTENCE}
crossdata.storage.stratioSecurity = false
crossdata.storage.stratioSecurity = ${?CROSSDATA_STORAGE_STRATIO_SECURITY}
crossdata.storage.stratioSecurityMode = "tls"
crossdata.storage.stratioSecurityMode = ${?CROSSDATA_STORAGE_STRATIO_SECURITY_MODE}
crossdata.security.enable-manager = false
crossdata.security.enable-manager = ${?CROSSDATA_SECURITY_MANAGER_ENABLED}
crossdata.security.manager.class = "com.stratio.gosec.dyplon.plugins.crossdata.GoSecCrossdataSecurityManager"
crossdata.security.manager.class = ${?CROSSDATA_SECURITY_MANAGER_CLASS}
crossdata.session.sparkjars-path = "/opt/sds/sparta/repo"
crossdata.sql.enable-native-queries = false
crossdata.sql.enable-native-queries = ${?CROSSDATA_SQL_NATIVE_QUERIES_ENABLED}

# Kafka for GOSEC
kafka.enable = false
kafka.enable = ${?SPARTA_PLUGIN_KAFKA_ENABLE}
kafka.producer.type = async
kafka.key.serializer = org.apache.kafka.common.serialization.StringSerializer
kafka.value.serializer = org.apache.kafka.common.serialization.StringSerializer
kafka.bootstrap.servers = "localhost:9092"
kafka.bootstrap.servers = ${?SPARTA_PLUGIN_KAFKA_BOOTSTRAP}
kafka.security.protocol = SSL
kafka.security.protocol = ${?SPARTA_PLUGIN_KAFKA_SEC_PROTOCOL}
kafka.ssl.truststore.location = ${?SPARTA_TLS_TRUSTSTORE_LOCATION}
kafka.ssl.truststore.password = ${?SPARTA_TLS_TRUSTSTORE_PASSWORD}
kafka.ssl.keystore.location = ${?SPARTA_TLS_KEYSTORE_LOCATION}
kafka.ssl.keystore.password = ${?SPARTA_TLS_KEYSTORE_PASSWORD}
kafka.ssl.key.password = ${?SPARTA_TLS_KEYSTORE_PASSWORD}

plugin.version = ${pom.version}
kafka.topic = audit
kafka.topic = ${?SPARTA_PLUGIN_KAFKA_TOPIC}
authorizer.default.policy = "Deny"
authorizer.resource.type = "file"
cache.enabled = true
cache.enabled = ${?SPARTA_PLUGIN_CACHE_ENABLED}
cache.ttl = 60000
cache.ttl = ${?SPARTA_PLUGIN_CACHE_TTL}
cache.ldap.size = 50
cache.ldap.size = ${?SPARTA_PLUGIN_LDAP_SIZE}
cache.ldap.interval = 5
cache.ldap.interval = ${?SPARTA_PLUGIN_LDAP_INTERVAL}
cache.ldap.ttl = 30
cache.ldap.ttl = ${?SPARTA_PLUGIN_LDAP_TTL}
local.hostname = ${?GOSEC_LOCAL_HOSTNAME}
java.security.auth.login.config = "/etc/sds/sparta/security/jaas.conf"
java.security.auth.login.config = ${?SPARTA_JAAS_FILE}
tenant.name =  ${?SPARTA_TENANT_NAME}

zookeeper.connect = "localhost:2181"
zookeeper.connect = ${?SPARTA_PLUGIN_ZK_CONNECT}
zookeeper.connection.timeout.ms = 6000
zookeeper.session.timeout.ms = 6000
zookeeper.root.path = "/stratio/gosec"
zookeeper.sasl.client = "true"
zookeeper.sasl.client = ${?SPARTA_PLUGIN_CLIENT_ZOOKEEPER_SASL_CLIENT}
zookeeper.watchers.enabled = true
zookeeper.watchers.enabled = ${?SPARTA_PLUGIN_ZOOKEEPER_WATCHERS}

ldap.host = "localhost"
ldap.host = ${?SPARTA_PLUGIN_LDAP_HOST}
ldap.port = 636
ldap.port = ${?SPARTA_PLUGIN_LDAP_PORT}
ldap.principal = "cn=ldaproot,dc=stratio,dc=com"
ldap.principal = ${?SPARTA_PLUGIN_LDAP_PRINCIPAL}
ldap.authetication = "simple"
ldap.credentials = "stratio"
ldap.credentials = ${?SPARTA_PLUGIN_LDAP_CREDENTIALS}
ldap.userDomain = "ou=People,dc=stratio,dc=com"
ldap.userDomain = ${?SPARTA_PLUGIN_LDAP_USER_DOMAIN}
ldap.groupDomain = "ou=Groups,dc=stratio,dc=com"
ldap.groupDomain = ${?SPARTA_PLUGIN_LDAP_GROUP_DOMAIN}
ldap.secured = true
ldap.secured = ${?SPARTA_PLUGIN_LDAP_SECURED}
ldap.schema = "RFC2307bis"
ldap.schema = ${?SPARTA_PLUGIN_LDAP_SCHEMA}
ldap.pool.maxPoolSize = 10
ldap.pool.maxPoolSize = ${?SPARTA_PLUGIN_LDAP_POOL_MAX_POOL_SIZE}
ldap.pool.minPoolSize = 1
ldap.pool.minPoolSize = ${?SPARTA_PLUGIN_LDAP_POOL_MIN_POOL_SIZE}
ldap.pool.validatePeriodically = "true"
ldap.pool.validatePeriodically = ${?SPARTA_PLUGIN_LDAP_POOL_VALIDATE_PERIODICALLY}
ldap.pool.validatePeriod = 30
ldap.pool.validatePeriod = ${?SPARTA_PLUGIN_LDAP_POOL_VALIDATE_PERIOD}
ldap.pool.validateOnCheckIn = "false"
ldap.pool.validateOnCheckIn = ${?SPARTA_PLUGIN_LDAP_POOL_VALIDATE_ON_CHECK_IN}
ldap.pool.validateOnCheckOut = "true"
ldap.pool.validateOnCheckOut = ${?SPARTA_PLUGIN_LDAP_POOL_VALIDATE_ON_CHECK_OUT}
ldap.mapping.user.id = "uid"
ldap.mapping.user.id = ${?SPARTA_PLUGIN_LDAP_MAPPING_USER_ID}
ldap.mapping.user.name = "cn"
ldap.mapping.user.name = ${?SPARTA_PLUGIN_LDAP_MAPPING_USER_NAME}
ldap.mapping.user.description = "description"
ldap.mapping.user.description = ${?SPARTA_PLUGIN_LDAP_MAPPING_USER_DESCRIPTION}
ldap.mapping.user.mail = "mail"
ldap.mapping.user.mail = ${?SPARTA_PLUGIN_LDAP_MAPPING_USER_MAIL}
ldap.mapping.group.id = "cn"
ldap.mapping.group.id = ${?SPARTA_PLUGIN_LDAP_MAPPING_GROUP_ID}
ldap.mapping.group.name = "description"
ldap.mapping.group.name = ${?SPARTA_PLUGIN_LDAP_MAPPING_GROUP_NAME}
ldap.mapping.group.member = "memberUid"
ldap.mapping.group.member = ${?SPARTA_PLUGIN_LDAP_MAPPING_GROUP_MEMBER}
ldap.mapping.group.description = "description"
ldap.mapping.group.description = ${?SPARTA_PLUGIN_LDAP_MAPPING_GROUP_DESCRIPTION}
ldap.matching.group.linkUser = "uid=%filter"
ldap.matching.group.linkUser = ${?SPARTA_PLUGIN_LDAP_MATCHING_GROUP_LINKUSER}
ldap.queries.user.queryAll = "(&(objectClass=person))"
ldap.queries.user.queryAll = ${?SPARTA_PLUGIN_LDAP_QUERIES_USER_QUERYALL}
ldap.queries.group.queryAll = "(&(objectClass=posixGroup))"
ldap.queries.group.queryAll = ${?SPARTA_PLUGIN_LDAP_QUERIES_GROUP_QUERYALL}
ldap.queries.group.groupByUser = "(&(objectClass=posixGroup)(memberUid=uid=%filter,ou=People,dc=stratio,dc=com))"
ldap.queries.group.groupByUser =  ${?SPARTA_PLUGIN_LDAP_QUERIES_GROUP_GROUPBYUSER}


#GOSEC Dyplon HTTP
#Crossdata
crossdata.security.plugin.version = 0.15.1-eff78cb
crossdata.security.plugin.version = ${?GOSEC_CROSSDATA_VERSION}
plugin.clientip = 0.0.0.0
plugin.clientip = ${?SPARTA_PLUGIN_XD_CLIENT_IP}
plugin.name = ${?CROSSDATA_PLUGIN_SERVICE_NAME}
plugin.version = ${pom.version}
plugin.instance = sparta
plugin.instance = ${?SPARTA_PLUGIN_INSTANCE}

#Not used in Sparta
api.endpoint.filter.row = "https://dyplon-http.marathon.mesos:8443/authorize/filter/row/{user}?service={service}&version={version}&instance={instance}&table={table}"
api.endpoint.filter.row = ${?SPARTA_PLUGIN_ENDPOINT_XD_FILTER_ROW}
api.endpoint.filter.columns = "https://dyplon-http.marathon.mesos:8443/authorize/filter/columns/{user}?service={service}&version={version}&instance={instance}&table={table}&columns={columns}"
api.endpoint.filter.columns = ${?SPARTA_PLUGIN_ENDPOINT_XD_FILTER_COLUMNS}
#Crossdata

#Api Dyplon Sparta
api.version = ${pom.version}
api.endpoint.tenant.param = ${?DYPLON_SYSTEM_TENANT}
api.service.name =  ${?SPARTA_PLUGIN_SERVICE_NAME}
api.local.hostname = ${?GOSEC_LOCAL_HOSTNAME}
api.dyplon.tenant.name = ${?DYPLON_TENANT_NAME}

#Api dyplon
api.server.cache = true
api.server.cache = ${?SPARTA_PLUGIN_CACHE_ENABLED}
api.endpoint.authorizer = "https://dyplon-http.marathon.mesos:8443/authorize/{user}?service={service}&version={version}&instance={instance}&action={action}&resourceType={resourceType}&value={value}&hierarchy={hierarchy}"
api.endpoint.authorizer = ${?SPARTA_PLUGIN_ENDPOINT_AUTHORIZER}
api.endpoint.register = "https://dyplon-http.marathon.mesos:8443/register"
api.endpoint.register = ${?SPARTA_PLUGIN_ENDPOINT_REGISTER}
api.endpoint.isregistered = "https://dyplon-http.marathon.mesos:8443/register/service/{service}/{version}/{instance}"
api.endpoint.isregistered = ${?SPARTA_PLUGIN_ENDPOINT_IS_REGISTERED}
#Facade security>
api.ssl.encryption = true
api.ssl.encryption = ${?SPARTA_PLUGIN_SSL_ENCRYPTATION}
api.ssl.clientAuth = true
api.ssl.clientAuth = ${?SPARTA_PLUGIN_CLIENT_AUTH}
api.ssl.client.keystore.location = ${?SPARTA_TLS_KEYSTORE_LOCATION}
api.ssl.client.keystore.password =  ${?SPARTA_TLS_KEYSTORE_PASSWORD}
api.ssl.client.keystore.key = ${?SPARTA_TLS_KEYSTORE_PASSWORD}
api.ssl.trustStore.location = ${?SPARTA_TLS_TRUSTSTORE_LOCATION}
api.ssl.trustStore.password = ${?SPARTA_TLS_TRUSTSTORE_PASSWORD}

#Facade cache
facade.auth.cache.enabled = true
facade.auth.cache.enabled = ${?SPARTA_PLUGIN_FACADE_CACHE_ENABLED}
facade.auth.cache.ttl = 60 s
facade.auth.cache.ttl = ${?SPARTA_PLUGIN_FACADE_CACHE_TTL}
facade.auth.cache.size = 100000
facade.auth.cache.size = ${?SPARTA_PLUGIN_FACADE_CACHE_SIZE}
facade.audit.message.asjson = true
facade.audit.message.asjson = ${?SPARTA_PLUGIN_FACADE_AUDIT_ASJSON}