/*
 * Copyright (C) 2015 Stratio (http://stratio.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.stratio.sparta.plugin.workflow.transformation.datetime

import java.io.{Serializable => JSerializable}
import java.lang.reflect.Method
import java.text.SimpleDateFormat
import java.util.{Date, Locale, TimeZone}

import com.github.nscala_time.time.Imports.DateTime
import com.stratio.sparta.sdk.workflow.step._
import org.apache.spark.sql.Row
import org.apache.spark.sql.crossdata.XDSession
import org.apache.spark.streaming.StreamingContext
import org.apache.spark.streaming.dstream.DStream
import org.joda.time.format.{DateTimeFormatter, ISODateTimeFormat}
import com.stratio.sparta.sdk.utils.AggregationTimeUtils._
import org.apache.spark.sql.catalyst.expressions.GenericRowWithSchema
import org.apache.spark.sql.types.{StructField, StructType}
import com.stratio.sparta.plugin.enumerations.FieldsPreservationPolicy._
import com.stratio.sparta.plugin.enumerations.DateFormatEnum._
import com.stratio.sparta.plugin.enumerations.{DateFormatEnum, FieldsPreservationPolicy}
import com.stratio.sparta.plugin.workflow.transformation.datetime.models.{DateTimeItem, DateTimeItemModel}
import com.stratio.sparta.sdk.properties.JsoneyStringSerializer
import org.json4s.{DefaultFormats, Formats}
import org.json4s.jackson.Serialization.read
import com.stratio.sparta.plugin.workflow.transformation.datetime.DateTimeTransformStep._
import com.stratio.sparta.sdk.DistributedMonad
import com.stratio.sparta.sdk.properties.ValidatingPropertyMap._

import scala.collection.mutable.ArrayBuffer
import scala.util.Try

abstract class DateTimeTransformStep[Underlying[Row]](
                                                       name: String,
                                                       outputOptions: OutputOptions,
                                                       ssc: Option[StreamingContext],
                                                       xDSession: XDSession,
                                                       properties: Map[String, JSerializable]
                                                     )(implicit dsMonadEvidence: Underlying[Row] => DistributedMonad[Underlying])
  extends TransformStep[Underlying](name, outputOptions, ssc, xDSession, properties)
    with ErrorCheckingStepRow with SchemaCasting {

  lazy val fieldsModel: Seq[DateTimeItemModel] = {
    implicit val json4sJacksonFormats: Formats = DefaultFormats + new JsoneyStringSerializer()
    read[Seq[DateTimeItemModel]](
      s"""${properties.get("fieldsDatetime").fold("[]") { values => values.toString }}""""
    )
  }

  lazy val itemsDatetime: Seq[DateTimeItem] = fieldsModel.map(transformToDateTimeItem)

  val validEmptyTimeGranularity: Set[String] = Set("millisecond", "second",
    "minute", "hour", "day", "week", "month", "year")

  //scalastyle:off

  override def transform(inputData: Map[String, DistributedMonad[Underlying]]): DistributedMonad[Underlying] =
    applyHeadTransform(inputData) { (inputSchema, inputStream) =>
      inputStream.flatMap(data => parse(data))
    }

  def applyOutputFormatToDate(date: Any)(implicit dateTimeItem: DateTimeItem): Any = {
    (date, dateTimeItem.outputFormatFrom) match {
      case (d: DateTime, USER) => setDateFormat(d.toDate, dateTimeItem.outputUserFormat.get)
      case (d: DateTime, STANDARD) => setDateFormat(d.toDate, dateTimeItem.outputStandardFormat.get)
      case (d: Long, USER) => setDateFormat(new Date(d), dateTimeItem.outputUserFormat.get)
      case (d: Long, STANDARD) => setDateFormat(new Date(d), dateTimeItem.outputStandardFormat.get)
      case _ => date
    }
  }

  def parse(row: Row): Seq[Row] =
    returnSeqDataFromRow {
      val inputSchema = row.schema
      val outputSchema = getNewOutputSchema(inputSchema)
      val mapValues = itemsDatetime.map {
        implicit itemDateTime: DateTimeItem =>
          val outputFieldStruct = retrieveStructType(itemDateTime)
          itemDateTime.formatFrom match {
            case AUTOGENERATED =>
              (itemDateTime.outputFieldName, castingToOutputSchema(outputFieldStruct, applyOutputFormatToDate(applyGranularity(new DateTime()))))
            case _ =>
              val inputValue = Option(row.get(inputSchema.fieldIndex(itemDateTime.inputField.get)))
              inputValue match {
                case Some(value) =>
                  Try {
                    (itemDateTime.outputFieldName, castingToOutputSchema(outputFieldStruct, applyOutputFormatToDate(applyGranularity(parseDate(value)))))
                  }.getOrElse(returnWhenError(new Exception(s"Impossible to parse outputField: ${itemDateTime.outputFieldName}")))
                case None =>
                  returnWhenError(new Exception(
                    s"Impossible to parse because the field ${outputFieldStruct.name} value is empty"))
              }
          }
      }.toMap


      val newValues = outputSchema.map { outputField =>
        mapValues.get(outputField.name) match {
          case Some(valueParsed) => valueParsed
          case _ =>
            Try(row.get(inputSchema.fieldIndex(outputField.name))).getOrElse(returnWhenError(
              new Exception(s"Impossible to parse outputField: $outputField in the schema")))
        }
      }
      new GenericRowWithSchema(newValues.toArray, outputSchema)
    }

  def parseDate(inputValue: Any)(implicit dateTimeItem: DateTimeItem): DateTime = {
    dateTimeItem.formatFrom match {
      case STANDARD =>
        dateTimeItem.standardFormat match {
          case Some("unix") =>
            new DateTime(inputValue.toString.toLong * 1000L)
          case Some("unixMillis") =>
            new DateTime(inputValue.toString.toLong)
          case Some("hive") =>
            new DateTime(getDateFromFormat(inputValue.toString))
          case Some(format) =>
            val formats = formatMethods
            if (formats.contains(format))
              formats(format).invoke(None).asInstanceOf[DateTimeFormatter].parseDateTime(inputValue.toString)
            else throw new Exception(s"The specified date format is not valid")
          case None =>
            throw new Exception(s"The specified date format is not valid")
        }
      case USER =>
        dateTimeItem.userFormat match {
          case Some(format) => new DateTime(getDateFromFormat(inputValue.toString, format, dateTimeItem.localeTime))
          case None => throw new Exception(s"The user date format is not valid")
        }
      case _ =>
        throw new Exception(s"The format is not supported")
    }
  }

  //scalastyle:on

  def applyGranularity(inputValue: DateTime)(implicit dateTimeItem: DateTimeItem): Any =
    dateTimeItem.granularity match {
      case Some(granularity) => truncateDate(inputValue, granularity)
      case None => inputValue
    }

  def getDateFromFormat(inputDate: String,
                        format: String = "yyyy-MM-dd HH:mm:ss",
                        locale: Locale = Locale.ENGLISH): Date = {
    val sdf = new SimpleDateFormat(format, locale)
    if (!format.contains("T") && !format.contains("z") && !format.contains("Z"))
      sdf.setTimeZone(TimeZone.getTimeZone("UTC"))
    sdf.parse(inputDate)
  }

  def setDateFormat(inputDate: Date,
                    format: String = "yyyy-MM-dd HH:mm:ss",
                    locale: Locale = Locale.ENGLISH): String = {
    val writeFormat = new SimpleDateFormat(format, locale)
    val out = writeFormat.format(inputDate)
    out
  }

  private def retrieveStructType(dateTimeItem: DateTimeItem): StructField =
    StructField(
      name = dateTimeItem.outputFieldName,
      dataType = SparkTypes.get(dateTimeItem.outputFieldType) match {
        case Some(sparkType) => sparkType
        case None => schemaFromString(dateTimeItem.outputFieldType)
      },
      nullable = dateTimeItem.nullable.getOrElse(true)
    )

  def getNewOutputSchema(inputSchema: StructType): StructType = {
    val newOutputSchema = ArrayBuffer[StructField]() ++ inputSchema
    itemsDatetime.foreach {
      itemDateTime: DateTimeItem =>
        val providedSchema: StructField = retrieveStructType(itemDateTime)
        itemDateTime.preservationPolicy match {
          case APPEND =>
            newOutputSchema += providedSchema
          case REPLACE =>
            val index = newOutputSchema.indexWhere(oldOut => oldOut.name.equals(itemDateTime.inputField.get))
            if (index != -1)
              newOutputSchema.update(index, providedSchema)
            else
              returnWhenError(throw new
                  Exception(s"The field specified as input does not exists in the current Row"))
          case JUST_EXTRACTED => Nil
        }
    }
    StructType(newOutputSchema)
  }


  def getGranularity(inputItem: DateTimeItemModel): Option[String] =
    (inputItem.granularityNumber.notBlank, inputItem.granularityTime.notBlank) match {
      case (Some(number), Some(time)) if !validEmptyTimeGranularity.contains(time) && number.trim.nonEmpty =>
        Some(number.concat(time))
      case (_, Some(time)) if validEmptyTimeGranularity.contains(time) => Option(time)
      case _ => None
    }

  def transformToDateTimeItem(dateTimeItemModel: DateTimeItemModel): DateTimeItem = {
    val formatFrom: DateFormat =
      Try(DateFormatEnum.withName(dateTimeItemModel.formatFrom.toUpperCase))
        .getOrElse(AUTOGENERATED)

    val preservation: FieldsPreservationPolicy =
      Try(FieldsPreservationPolicy.withName(dateTimeItemModel.fieldsPreservationPolicy.toUpperCase))
        .getOrElse(if (formatFrom.equals(AUTOGENERATED)) APPEND else REPLACE)

    val outputFormatFrom: DateFormat =
      Try(DateFormatEnum.withName(dateTimeItemModel.outputFormatFrom.toUpperCase))
        .getOrElse(DEFAULT)

    val granularity = getGranularity(dateTimeItemModel)

    val locale = dateTimeItemModel.localeTime.fold(Locale.ENGLISH) { x =>
      localeMapping.getOrElse(x, Locale.ENGLISH)
    }

    val item = DateTimeItem(dateTimeItemModel.inputField.notBlank,
      formatFrom,
      dateTimeItemModel.userFormat.notBlank,
      dateTimeItemModel.standardFormat.notBlank,
      locale,
      granularity,
      preservation,
      dateTimeItemModel.outputFieldName,
      dateTimeItemModel.outputFieldType,
      dateTimeItemModel.nullable,
      outputFormatFrom,
      dateTimeItemModel.outputUserFormat.notBlank,
      dateTimeItemModel.outputStandardFormat.notBlank
    )
    if (isValidItem(item))
      item
    else
      throw new Exception("The provided datetime transformation is not valid")
  }

  private def isValidAppendPolicy()(implicit dateTimeItem: DateTimeItem): Boolean =
    dateTimeItem.inputField.notBlank.isEmpty || !dateTimeItem.outputFieldName.equals(dateTimeItem.inputField.get)

  private def isValidAutogenerated()(implicit dateTimeItem: DateTimeItem): Boolean =
    dateTimeItem.preservationPolicy.equals(APPEND) && isValidAppendPolicy

  private def isValidStandardOrUser()(implicit dateTimeItem: DateTimeItem): Boolean =
    !dateTimeItem.preservationPolicy.equals(APPEND) || isValidAppendPolicy

  private def isValidOutputFormat(implicit dateTimeItem: DateTimeItem): Boolean =
    dateTimeItem.outputFormatFrom match {
      case STANDARD => dateTimeItem.outputStandardFormat.notBlank.isDefined &&
        dateTimeItem.outputFieldType.equals("string")
      case USER => dateTimeItem.outputUserFormat.notBlank.isDefined &&
        dateTimeItem.outputFieldType.equals("string")
      case _ => true
    }

  def isValidItem(implicit dateTimeItem: DateTimeItem): Boolean =
    (dateTimeItem.formatFrom match {
      case AUTOGENERATED => isValidAutogenerated()
      case _ => isValidStandardOrUser()
    }) && isValidOutputFormat
}

object DateTimeTransformStep {

  val formatMethods: Map[String, Method] = classOf[ISODateTimeFormat].getMethods.toSeq.map(x => (x.getName, x)).toMap

  val localeMapping: Map[String, Locale] = Map(
    "ENGLISH" -> Locale.ENGLISH,
    "SPANISH" -> new Locale("es", "es"),
    "FRENCH" -> Locale.FRENCH,
    "GERMAN" -> Locale.GERMAN,
    "ITALIAN" -> Locale.ITALIAN,
    "JAPANESE" -> Locale.JAPANESE,
    "KOREAN" -> Locale.KOREAN,
    "CHINESE" -> Locale.CHINESE,
    "GREEK" -> new Locale("el", "el"),
    "PORTUGUESE" -> new Locale("pt", "pt"),
    "RUSSIAN" -> new Locale("ru", "ru")
  )

}

